<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Theme | Learn Elixir Language]]></title>
  <link href="http://learnelixir.com/blog/categories/theme/atom.xml" rel="self"/>
  <link href="http://learnelixir.com/"/>
  <updated>2014-10-22T13:55:12+08:00</updated>
  <id>http://learnelixir.com/</id>
  <author>
    <name><![CDATA[Learn Elixir]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Seven RESTful Actions in Phoenix Web App]]></title>
    <link href="http://learnelixir.com/blog/2014/10/18/seven-restful-actions-in-phoenix-web-app/"/>
    <updated>2014-10-18T23:20:53+08:00</updated>
    <id>http://learnelixir.com/blog/2014/10/18/seven-restful-actions-in-phoenix-web-app</id>
    <content type="html"><![CDATA[<p>For a new web application framework, I always start with building a 7 actions RESTful app to try out how good the framework is, and so far for Phoenix, it looks quite promising in term of code readability and the speed of churning out these 7 actions for a model entity. As these 7 RESTful actions are the backbone of the most web apps nowadays, it is crucial that we are familiar with the steps to create them.</p>

<!-- more -->


<p>In this article, we are going through the process of creating these 7 RESTful actions. These 7 actions are <code>index</code>, <code>new</code>, <code>create</code>, <code>edit</code>, <code>update</code>, <code>destroy</code> and <code>show</code>. The <code>index</code> action has already been covered in the very first article of this blog, but for the sake of completeness, it will be recovered in this article.</p>

<p>Anyway, here is the end result:</p>

<p>{% img center /images/7restful-action/screenshot.png 500 396 &lsquo;image&rsquo; &lsquo;images&rsquo; %}</p>

<p>You are able to download the source code on github -</p>

<p><a href="https://github.com/learnelixir/hardware-zone">https://github.com/learnelixir/hardware-zone</a></p>

<p>as well as check the application online - deployed to Heroku Server at</p>

<p><a href="http://phoenix-hardware-zone.herokuapp.com">http://phoenix-hardware-zone.herokuapp.com</a></p>

<p>Let&rsquo;s start with create an application for this. We will be building a public hardware parts posting site where user will be able to post a hardware and other users will be able to see it.</p>

<h3>0 - Setup</h3>

<p>Let&rsquo;s start by creating a new project</p>

<pre><code class="bash">$ cd &lt;phoenix_directory&gt;
$ mix phoenix.new hardward_zone ../
</code></pre>

<p>This will create a all the stuffs that we need to develop the app. Now let&rsquo;s move to that project folder and install all the dependencies by typing the following commands:</p>

<pre><code class="bash">$ cd ../
$ mix deps.get
</code></pre>

<p>Next, we will need to add in 2 <code>postgrex</code> and <code>ecto</code> library for our database.</p>

<pre><code class="bash">$ vim mix.exs
</code></pre>

<p>Add in line 5 and 6 in the following code to <code>deps</code> method</p>

<pre><code class="elixir">defp deps do
  [
    {:phoenix, "0.4.1"},
    {:cowboy, "~&gt; 1.0.0"},
    {:postgrex, "~&gt; 0.5"},
    {:ecto, "~&gt; 0.2.0"}
  ]
end
</code></pre>

<p>Also, in the same file, we will also need to add in <code>postgrex</code> and <code>ecto</code> application in <code>application</code> method</p>

<pre><code class="elixir"># Configuration for the OTP application
def application do
  [   
    mod: { HardwareZone, [] },
    applications: [:phoenix, :cowboy, :logger, :postgrex, :ecto]
  ]   
end 
</code></pre>

<p>Install the dependencies again:</p>

<pre><code class="bash">$ mix deps.get
</code></pre>

<p>Now let go ahead and create a model named <code>hardware</code>. This model will be our central entity, which we will need to have a function to list all the hardwares on our home page, let user to view, create, update and remove individually. To start with this, let&rsquo;s create a Repo file to interface with postgres database:</p>

<pre><code class="bash">$ vim web/models/repo.ex
</code></pre>

<p>And copy the below code into this file. Remember to change <code>postgresuser</code> and <code>password</code> to the correct username and password of your postgres database:</p>

<pre><code class="elixir">defmodule HardwareZone.Repo do
  use Ecto.Repo, adapter: Ecto.Adapters.Postgres

  def conf do
    parse_url "ecto://postgresuser:password@localhost/hardware_zone"
  end 

  def priv do
    app_dir(:hardware_zone, "priv/repo")
  end 
end
</code></pre>

<p>Now, we will need to make sure this <code>Repo</code> module to be started with our application and supervised. We can do this by editing <code>lib/hardware_zone.ex</code> and add in the worker to the list of supervised children. It is line 7 in the code below:</p>

<pre><code class="elixir">def start(_type, _args) do
  import Supervisor.Spec, warn: false

  children = [ 
    # Define workers and child supervisors to be supervised
    # worker(TestApp.Worker, [arg1, arg2, arg3])
    worker(HardwareZone.Repo, [])
  ]   

  opts = [strategy: :one_for_one, name: HardwareZone.Supervisor]
  Supervisor.start_link(children, opts)
end 
</code></pre>

<p>Next, we will need to manually create a postgres database named <code>hardware_zone</code> by typing the following into your terminal:</p>

<pre><code class="bash">$ createdb hardware_zone --encoding='utf-8' --locale=en_US.UTF-8 --template=template0; 
</code></pre>

<p>This will create <code>hardware_zone</code> postgres database with utf8 encoding</p>

<p>Let&rsquo;s move on by creating a <code>hardware</code> model now:</p>

<pre><code class="bash">$ vim web/models/hardware.ex
</code></pre>

<p>And paste in the following code:</p>

<pre><code class="elixir">defmodule HardwareZone.Hardware do
  use Ecto.Model
  validate hardware, name: present()

  schema "hardwares" do
    field :name, :string
    field :description
    field :manufacturer
    field :sale_contact_number
  end 
end
</code></pre>

<p>Next, generate a migration script by the following in command in your terminal</p>

<pre><code class="bash">$ mix ecto.gen.migration HardwareZone.Repo create_hardware
</code></pre>

<p>This command will create a folder <code>migrations</code> under <code>priv/repo</code> and the migration file under this newly created <code>migrations</code> folder. You can go ahead and edit this migration file. In my case, it is <code>20141019010800_create_hardware.exs</code></p>

<pre><code class="bash">$ vim priv/repo/migrations/20141019010800_create_hardware.exs
</code></pre>

<p>then paste in the following code</p>

<pre><code class="elixir">defmodule HardwareZone.Repo.Migrations.CreateHardware do
  use Ecto.Migration

  def up do
    "CREATE TABLE hardwares( \
            id serial primary key, \
            name varchar(125), \
            description text, \
            manufacturer varchar(255), \
            sale_contact_number varchar(255))"
  end 

  def down do
    "DROP TABLE hardwares"
  end 
end
</code></pre>

<p>In <code>up</code> function we are creating a table <code>hardwares</code>. This <code>up</code> function will run when we run the migration. In <code>down</code> function, we will drop the table that we create in <code>up</code> function, this will run when we rollback this migration. Let&rsquo;s move on by running this migration:</p>

<pre><code class="bash">$ mix ecto.migrate HardwareZone.Repo
</code></pre>

<p>In case that you make a mistake and would like to rollback, you can run the following command:</p>

<pre><code class="bash">$ mix ecto.rollback HardwareZone.Repo
</code></pre>

<p>Next, we will need to create a module to store all the hardwares database queries. Let&rsquo;s create <code>web/models/queries.ex</code></p>

<pre><code class="bash">$ vim web/models/queries.ex 
</code></pre>

<p>and paste in the following code:</p>

<pre><code class="elixir">defmodule HardwareZone.Queries do
  import Ecto.Query

  def all_hardwares do
    query = from hardware in HardwareZone.Hardware, \
            select: hardware

    HardwareZone.Repo.all(query)
  end 
end
</code></pre>

<p>Next, edit <code>web/router.ex</code> to include RESTful routes to the approriate controller</p>

<pre><code class="bash">$ vim web/router.ex 
</code></pre>

<p>and paste in the source code below</p>

<pre><code class="elixir">defmodule HardwareZone.Router do
  use Phoenix.Router

  get "/", HardwareZone.HardwaresController, :index, as: :root
  resources "/hardwares", HardwareZone.HardwaresController
end
</code></pre>

<p>We have added 2 routes, the first <code>get</code> line is to route the user to the index page of all the hardwares, i.e. it is the index page. On the second line, we are using <code>resources</code> function to route all the 7 RESTful actions to the approriate action in <code>HardwareZone.HardwaresController</code> that we are going to create. To verify all the routes are in, let&rsquo;s run the following command to check:</p>

<pre><code class="bash">$ mix phoenix.routes
</code></pre>

<p>The following should come out from your terminal</p>

<pre><code class="bash">         root_path  GET     /                    HardwareZone.HardwaresController.index/2
hardwares_path  GET     /hardwares           HardwareZone.HardwaresController.index/2
hardwares_path  GET     /hardwares/:id/edit  HardwareZone.HardwaresController.edit/2
hardwares_path  GET     /hardwares/new       HardwareZone.HardwaresController.new/2
hardwares_path  GET     /hardwares/:id       HardwareZone.HardwaresController.show/2
hardwares_path  POST    /hardwares           HardwareZone.HardwaresController.create/2
hardwares_path  PUT     /hardwares/:id       HardwareZone.HardwaresController.update/2
                    PATCH   /hardwares/:id       HardwareZone.HardwaresController.update/2
hardwares_path  DELETE  /hardwares/:id       HardwareZone.HardwaresController.destroy/2
</code></pre>

<p>The first column is the helper function name, which we will come back to it shortly. The second column is the HTTP web action that needs to be triggered. The third column is the relative URL to our application that needs to be trigger and the last column is the corresponding action to serve the triggered route.</p>

<p>Let try to start the phoenix server by running the following command from your terminal</p>

<pre><code class="bash">$ mix phoenix.start
</code></pre>

<p>At this point of time, if you visit <a href="http://localhost:4000,">http://localhost:4000,</a> it will show you the following error</p>

<pre><code class="bash">(UndefinedFunctionError) undefined function: HardwareZone.HardwaresController.call/2 
(module HardwareZone.HardwaresController is not available)
</code></pre>

<p>The reason why is because we have not create any controller and index action to cater for root routes. Let&rsquo;s create <code>HardwareZone.HardwaresController</code> now</p>

<pre><code class="bash">$ vim web/controller/hardwares_controller.ex
</code></pre>

<p>and paste in the following initial code</p>

<pre><code class="elixir">defmodule HardwareZone.HardwaresController do
  use Phoenix.Controller
  alias HardwareZone.Hardware
  alias HardwareZone.Repo
  alias HardwareZone.Router
end
</code></pre>

<p>Next, let clean up a bit on the application view layout by editing file <code>web/templates/layout/application.html.eex</code></p>

<pre><code class="bash">$ vim web/templates/layout/application.html.eex
</code></pre>

<p>and replace by the following code. Note that I have removed the phoenix default header and footer</p>

<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;
    &lt;meta name="description" content=""&gt;
    &lt;meta name="author" content=""&gt;

    &lt;title&gt;Hardware Zone&lt;/title&gt;
    &lt;link rel="stylesheet" 
          href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css"&gt;
    &lt;link rel="stylesheet" 
          href="http://learnelixir.com/css/app.css"&gt;
    &lt;script src="https://code.jquery.com/jquery-1.11.1.min.js"&gt;&lt;/script&gt;
    &lt;script src="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"&gt;&lt;/script&gt;
    &lt;script src="https://raw.githubusercontent.com/rails/jquery-ujs/master/src/rails.js"&gt;&lt;/script&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;div class="navbar navbar-inverse navbar-fixed-top" role="navigation"&gt;
      &lt;div class="container-fluid"&gt;
        &lt;div class="navbar-header"&gt;
          &lt;button type="button" 
                  class="navbar-toggle" 
                  data-toggle="collapse" 
                  data-target=".navbar-collapse"&gt;
            &lt;span class="sr-only"&gt;Toggle navigation&lt;/span&gt;
            &lt;span class="icon-bar"&gt;&lt;/span&gt;
            &lt;span class="icon-bar"&gt;&lt;/span&gt;
            &lt;span class="icon-bar"&gt;&lt;/span&gt;
          &lt;/button&gt;
          &lt;a class="navbar-brand" href="http://learnelixir.com/"&gt;Hardware Zone&lt;/a&gt;
        &lt;/div&gt;
        &lt;div class="collapse navbar-collapse"&gt;
          &lt;ul class="nav navbar-nav"&gt;
            &lt;li&gt;&lt;a href="&lt;%= HardwareZone.Router.hardwares_path(:new) %&gt;"&gt;+ New Hardware&lt;/a&gt;&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/div&gt;&lt;!--/.nav-collapse --&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="container-fluid"&gt;
      &lt;div class='starter-template'&gt;
        &lt;%= @inner %&gt;
      &lt;/div&gt;
    &lt;/div&gt; &lt;!-- /container --&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<ul>
<li>On line 38, we are making use of the Router helper to link to the New hardware page.</li>
<li>On line 45, the code <code>&lt;%= @inner %&gt;</code> is used to render the content that you create in order view.</li>
<li>On line 15 and 17, note that I have added in <code>jquery</code> library and borrow <code>jquery-ujs</code> from rails to support the delete function later on.</li>
</ul>


<p>Now, replace the content in file <code>priv/static/css/app.css</code> by</p>

<pre><code class="css">body {
  padding: 50px 15px;
}

div.hardware-box {
  border: 1px solid #ccc;
  padding: 10px;
  height: 135px;
  background: #efefef;
  margin-top: 30px;
  cursor: pointer;
}

div.hardware-box div.title {
  font-weight: bold;
  font-size: 14px;
  height: 20px;
  overflow: hidden;
}

div.hardware-box div.manufacturer {
  color: #999;
}

div.hardware-box div.description {
  margin-top: 10px;
  height: 60px;
  overflow: hidden;
}

div#error_explanation {
  background: #BA5353;
  color: #fff;
  padding: 10px;
  margin-bottom: 10px;
  border-radius: 5px;
}

div#error_explanation div.error-title {
  padding: 0;
  margin-bottom: 5px;
  font-weight: bold;
  margin-left: -10px;
  margin-top: -10px;
  margin-right: -10px;
  padding: 10px;
  background: #AD2020;
  border-radius: 5px 5px 0 0;
}

div#error_explanation ul {
  list-style-type: decimal;
  padding-left: 20px;
  margin-bottom: 0;
}
</code></pre>

<p>Now, we are ready. It&rsquo;s time for us to create 7 actions. Let&rsquo;s start with index action&hellip;</p>

<h3>1 - Index action</h3>

<p>Start by editing <code>hardwares_controller</code>:</p>

<pre><code class="bash">$ vim web/controller/hardwares_controller.ex
</code></pre>

<p>and paste in the following <code>index</code> action</p>

<pre><code class="elixir">def index(conn, _params) do
  hardwares = HardwareZone.Queries.all_hardwares
  render conn, "index", hardwares: hardwares
end 
</code></pre>

<p>In this <code>index</code> action, what we have done is querying all the hardwares from our database and render these structs objects inside <code>index</code> view using the <code>render</code> command. Since we do not have an <code>index</code> page at the moment, let&rsquo;s create one by first creating <code>hardware_view.ex</code> in <code>web/views</code> folder:</p>

<pre><code class="bash">$ vim web/views/hardwares_view.ex
</code></pre>

<p>with the following code:</p>

<pre><code class="elixir">defmodule HardwareZone.HardwaresView do
  use HardwareZone.Views
end
</code></pre>

<p>Then create the hardwares template folder:</p>

<pre><code class="bash">$ mkdir -p web/templates/hardwares
</code></pre>

<p>Then create file <code>web/templates/hardwares/index.html.eex</code>:</p>

<pre><code class="bash">$ vim web/templates/hardwares/index.html.eex
</code></pre>

<p>paste in the following code</p>

<p>&#8220;`html</p>

<div class="row">
  <%= for hardware <- @hardwares do %>
    <div class="col-xs-6 col-md-4">
      <div class='hardware-box' 
           data-url='<%= HardwareZone.Router.hardwares_path(:show, hardware.id) %>&#8217;>
        <div class='title'><%= hardware.name %></div>
        <div class='manufacturer'><%= hardware.manufacturer %></div>
        <div class='description'><%= hardware.description %></div>
      </div>
    </div>
  <% end %>

  <script language='javascript'>
    $(document).ready(function() {
      $(document.body).delegate("div.hardware-box", "click", function() {
        document.location = $(this).attr("data-url");
      });
    });
  </script>
</div>


<pre><code>
It is a loop though all ``@hardwares`` object and render out the corresponing HTML. Note that you will need ``&lt;%= `` in ``for`` loop so that your content can be printed out correctly.

Now visit http://localhost:4000. What you can see will just be the navigation bar. This is because we do not have any hardwares in our database yet. Let's create a seeds file to add some initial hardwares. You will need to create file ``seeds.ex`` on the application root folder:
</code></pre>

<p>$ vim seeds.ex
&#8220;`</p>

<p>with the following code:</p>

<pre><code class="elixir">hardwares = [ 
  %{
    name: "Macbook Pro", 
    description: "Looks like new, in good condition, used for 1.5 years", 
    manufacturer: "Apple", 
    sale_contact_number: "912345678" 
  }, 
  %{
    name: "Toshiba CB35-B3340 Chromebook 2",
    description: "This is thinner and lighter than its predecessor. Used for 2 years",
    manufacturer: "Toshiba",
    sale_contact_number: "987654321"
  },
  %{
    name: "HP Chromebook 11 (Verizon LTE)",
    description: "The design and construction of the laptop still looks good. Used for 1 year",
    manufacturer: "HP",
    sale_contact_number: "998765432"
  }
]

for hardware &lt;- hardwares do
  new_hardware = Map.merge(%HardwareZone.Hardware{}, hardware)
  HardwareZone.Repo.insert(new_hardware)
end
</code></pre>

<p>Then run this seeds file from your terminal:</p>

<pre><code class="bash">$ mix run seeds.ex
</code></pre>

<p>Now refresh the page, you should already see some hardwares displayed on the index page. Let&rsquo;s move on to create a hardware.</p>

<h3>2 - New Action</h3>

<p>As usual, let&rsquo;s start by editing <code>hardwares_controller.ex</code></p>

<pre><code class="bash">$ vim web/controller/hardwares_controller.ex
</code></pre>

<p>Add in the following function:</p>

<pre><code class="elixir">def new(conn, _params) do
  render conn, "new", hardware: %Hardware{}
end 
</code></pre>

<p>Next, create <code>new.html.eex</code> file:</p>

<pre><code class="bash">$ vim web/templates/hardwares/new.html.eex
</code></pre>

<p>with the following content</p>

<p>&#8220;`html</p>

<h1>New Hardware </h1>


<p><br/>
&lt;%= render &ldquo;form.html&rdquo;, hardware: @hardware, errors: @errors %>
&#8220;`</p>

<p>As we are trying to render a form view from this view, we will need to create a view named <code>web/templates/hardwares/form.html.eex</code>. This is different from Rails, where you will need to create this partial view file name with under score (<code>_</code>). The partial view file does not to be suffixed with underscore (<code>_</code>).</p>

<pre><code class="bash">$ vim web/templates/hardwares/form.html.eex
</code></pre>

<p>and use following code content:</p>

<p>Note that line 1 to 13 are for errors displaying. In addition, in this form&rsquo;s action, we are actually checking if the hardware is a new record by looking into its id. If it is, we will just render the create path. otherwise, the update path will be used. Anoter note is from line 21 - 23 where we need to put extra hidden field with <code>PUT</code> method so that it can be sent over the HTTP request. For <code>PUT</code> and <code>DELETE</code>, it cannot be specified inside a HTML form method attribute.</p>

<pre><code class="html">&lt;%= if @errors do %&gt;
  &lt;div id='error_explanation'&gt;
    &lt;div class='error-title'&gt;
      This form contains &lt;%= errors_count = Enum.count(@errors) %&gt; 
      &lt;%= if errors_count == 1, do: "error", else: "errors" %&gt;:
    &lt;/div&gt;
    &lt;ul&gt;
      &lt;%= for {key, value} &lt;- @errors do %&gt;
        &lt;li&gt;&lt;%= String.capitalize(Atom.to_string(key)) %&gt; &lt;%= value %&gt;&lt;/li&gt; 
      &lt;% end %&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;% end %&gt;
&lt;form 
  action="&lt;%= if @hardware.id, 
     do: HardwareZone.Router.hardwares_path(:update, @hardware.id), 
     else: HardwareZone.Router.hardwares_path(:create) %&gt;" 
  method="post" 
  enctype="multipart/form-data"&gt;

  &lt;%= if @hardware.id do %&gt; 
    &lt;input type="hidden" name="_method" value="PUT" /&gt;
  &lt;% end %&gt;

  &lt;div class="form-group"&gt;
    &lt;label for="hardware[name]"&gt;Name&lt;/label&gt;
    &lt;input type="text" name="hardware[name]" class="form-control" value='&lt;%= @hardware.name %&gt;'/&gt;
  &lt;/div&gt;
  &lt;div class="form-group"&gt;
    &lt;label for="hardware[description]"&gt;Description&lt;/label&gt;
    &lt;textarea 
      name="hardware[description]" 
      class="form-control"&gt;&lt;%= @hardware.description %&gt;&lt;/textarea&gt;
  &lt;/div&gt;
  &lt;div class="form-group"&gt;
    &lt;label for="hardware[manufacturer]"&gt;Manufacturer&lt;/label&gt;
    &lt;input type="text" 
           name="hardware[manufacturer]" 
           class="form-control" 
           value='&lt;%= @hardware.manufacturer %&gt;'/&gt;
  &lt;/div&gt;
  &lt;div class="form-group"&gt;
    &lt;label for="hardware[sale_contact_number]"&gt;Sale Contact Numbner&lt;/label&gt;
    &lt;input type="text" 
           name="hardware[sale_contact_number]" 
           class="form-control" 
           value='&lt;%= @hardware.sale_contact_number %&gt;'/&gt;
  &lt;/div&gt;

  &lt;button type="submit" class="btn btn-primary"&gt;Save&lt;/button&gt;
  &amp;nbsp;&amp;nbsp;or
  &lt;a href='&lt;%= HardwareZone.Router.hardwares_path(:index) %&gt;'&gt;Cancel&lt;/a&gt;
&lt;/form&gt;
&lt;br/&gt;
</code></pre>

<p>Now if you visit <a href="http://localhost:4000/hardwares/new,">http://localhost:4000/hardwares/new,</a> you should see the form. In order to create a hardware, let&rsquo;s move to create a <code>create</code> action to save this form.</p>

<h4>3 - Create Action</h4>

<p>Let&rsquo;s start with controller <code>hardwares_controller.ex</code>:</p>

<pre><code class="bash">$ vim web/controller/hardwares_controller.ex
</code></pre>

<p>and add in the following functions:</p>

<pre><code class="elixir">def create(conn, %{"hardware" =&gt; params}) do
  hardware = Map.merge(%Hardware{}, atomize_keys(params))
  case Hardware.validate(hardware) do
    [] -&gt;
      hardware = Repo.insert(hardware)
      redirect conn, Router.hardwares_path(:show, hardware.id)
    errors -&gt;
      render conn, "new", hardware: hardware, errors: errors
  end 
end

defp atomize_keys(struct) do
  Enum.reduce struct, %{}, fn({k, v}, map) -&gt; Map.put(map, String.to_atom(k), v) end 
end 
</code></pre>

<p>We have defined another helper private function <code>atomize_keys</code> (<code>defp</code> stands for private definition) which is responsible for converting a struct with string key to a struct with atom key. We then merge the atomized params with the empty <code>Hardware</code> struct, validate the Hardware at line 3, insert at line 5 before redirect the page to <code>show</code> action. If the hardware has validation errors, it will render back the <code>new</code> action at line 8. Let&rsquo;s move on to show action before we can try out the create function.</p>

<h4>4 - Show Action</h4>

<p>Again, let add the following <code>show</code> action in controller <code>web/controller/hardware_controller.ex</code></p>

<pre><code class="bash">$ vim web/controller/hardware_controller.ex
</code></pre>

<p>The <code>show</code> action code is as below:</p>

<pre><code class="elixir">def show(conn, %{"id" =&gt; id}) do
  case Repo.get(Hardware, String.to_integer(id)) do
    hardware when is_map(hardware) -&gt;
      render conn, "show", hardware: hardware
    _ -&gt;  
      redirect conn, Router.hardwares_path(:index)
end
</code></pre>

<p>The code above starts by checking for the existence of the hardware with given parameter name <code>id</code>. By using the <code>case</code> condition on line 2 and the guard condition <code>is_map(hardware)</code> on line 3, it is guaranteed that the hardware does exist to show on line 4. Otherwise, it will redirect to the hardware index page.</p>

<p>Because we are rendering a <code>show</code> view on line 4, let&rsquo;s add <code>show</code> view by creating file <code>web/templates/hardwares/show.html.eex</code></p>

<pre><code class="bash">$ vim web/templates/hardwares/show.html.eex
</code></pre>

<p>with the following code content</p>

<p>&#8220;`html
<br/>
<a href='<%= HardwareZone.Router.hardwares_path(:index) %>&lsquo;>&larr; List of Hardwares</a></p>

<h1><%= @hardware.name %></h1>


<p><span class='manufacturer'>&lt;%= @hardware.manufacturer %></span></p>

<p><br/></p>

<div class='description'><%= @hardware.description %></div>


<p>&lt;%= if @hardware.sale_contact_number do %>
  Want to buy, contact me at: &lt;%= @hardware.sale_contact_number %>
&lt;% end %>
<br/><br/></p>

<p><a href='<%= HardwareZone.Router.hardwares_path(:edit, @hardware.id) %>&lsquo;
   class=&#8217;btn btn-primary&rsquo;>Edit</a>
&nbsp;
<a href='<%= HardwareZone.Router.hardwares_path(:destroy, @hardware.id) %>&lsquo;
   class=&#8217;btn btn-danger&rsquo;
   data-confirm=&ldquo;Are you sure that you want to delete this hardware?&rdquo;
   data-method=&ldquo;DELETE&rdquo;>Remove</a>
&#8220;`</p>

<p>Take note that line 19 to 22 are for the delete button with <code>data-confirm</code> and <code>data-method</code> attribute. If you click on it, it will trigger the confirm window and submit with <code>DELETE</code> HTTP method to that link URL. This can be achieved thank to the <code>jquery-ujs</code> that we put inside <code>head</code> tag earlier.</p>

<p>Now let&rsquo;s move on to <code>edit</code> action.</p>

<h4>5 - Edit Action</h4>

<p>Start with controller code <code>web/controllers/hardwares_controller.ex</code></p>

<pre><code class="bash">$ vim web/controllers/hardwares_controller.ex
</code></pre>

<p>and add in <code>edit</code> action</p>

<pre><code class="elixir">def edit(conn, %{"id" =&gt; id}) do
  case Repo.get(Hardware, String.to_integer(id)) do
    hardware when is_map(hardware) -&gt;
      render conn, "edit", hardware: hardware
    _ -&gt;
      redirect conn, Router.hardwares_path(:index)
  end 
end 
</code></pre>

<p>This is quite similar to <code>show</code> action whereby a query for the Hardware using parameter id happens on line 2 and after that a rendering <code>edit</code> view if there is such a hardware. Otherwise, it redirects to index action. Now, let&rsquo;s create <code>edit</code> view for this action:</p>

<pre><code class="bash">$ vim web/templates/hardwares/edit.html.eex
</code></pre>

<p>and paste in the code below:</p>

<p>&#8220;`html</p>

<h2>Edit Hardware</h2>


<p><br/>
&lt;%= render &ldquo;form.html&rdquo;, hardware: @hardware, errors: @errors %>
&#8220;`</p>

<p>As you notice, the same form view except the header can be employed for the <code>edit</code> action by using <code>render</code>. Now, to make this <code>edit</code> form be able to save the data, let&rsquo;s create <code>update</code> action.</p>

<h4>6 - Update Action</h4>

<p>First, edit <code>web/controllers/hardwares_controller.ex</code>:</p>

<pre><code class="bash">$ vim web/controllers/hardwares_controller.ex
</code></pre>

<p>and add in the <code>update</code> function as below:</p>

<pre><code class="elixir">def update(conn, %{"id" =&gt; id, "hardware" =&gt; params}) do
  case Repo.get(Hardware, String.to_integer(id)) do
    hardware when is_map(hardware) -&gt;
      hardware = Map.merge(hardware, atomize_keys(params))
      case Hardware.validate(hardware) do
        [] -&gt;  
          Repo.update(hardware)
          redirect conn, Router.hardwares_path(:show, hardware.id)
        errors -&gt;  
          render conn, "edit", hardware: hardware, errors: errors
      end 
    _ -&gt;
      redirect conn, Router.hardwares_path(:index)
  end 
end
</code></pre>

<p>Since there are a few things happening here, let&rsquo;s go through this piece of code line by line so that we can understand more:</p>

<ul>
<li>On line 1, as usual it is the function with the second parameters which are the parameters sent from front end. We will need to split these parameters to <code>id</code> and the <code>hardware</code> struct.</li>
<li>On line 2, we will then try to get the corresponding database record. Note that you will need to convert <code>id</code> to integer before you can use <code>Repo.get</code>.</li>
<li>On line 3, the <code>case</code> code will only go to this branch if the result of <code>Repo.get</code> is a map, which implies that there is such record inside our database.</li>
<li>On line 4, we then merge the current database record with the keys atomized <code>hardware</code> data sent from front end.</li>
<li>On line 5, validation kicks in to validate the updated <code>hardware</code></li>
<li>On line 6, the <code>case</code> code will only go to this branch if no errors are detected</li>
<li>On line 7, trigger the actual update using <code>Repo.update</code></li>
<li>On line 8, after update, it redirects back to show the hardware.</li>
<li>On line 9, the <code>case</code> code will go to this branch if errors occur during validation</li>
<li>On line 10, because of the error, we will re-render <code>edit</code> action with the attached <code>errors</code></li>
</ul>


<p>That&rsquo;s it for update action. Now let&rsquo;s move on to destroy or delete action</p>

<h4>7 - Destroy action</h4>

<p>We only need to add in destroy function inside <code>web/controllers/hardwares_controller.ex</code></p>

<pre><code class="bash">$ vim web/controllers/hardwares_controller.ex
</code></pre>

<p>and add this the destroy action as below:</p>

<pre><code class="elixir">def destroy(conn, %{"id" =&gt; id}) do
  case Repo.get(Hardware, String.to_integer(id)) do
    hardware when is_map(hardware) -&gt;
      Repo.delete(hardware)
      redirect conn, Router.hardwares_path(:index)
    _ -&gt;
      redirect conn, Router.hardwares_path(:index)
  end
end
</code></pre>

<h3>Wrap Up</h3>

<p>I hope you have enjoyed building a 7 action Phoenix app with Elixir. If you want to extend this basic app, it will play as a good exercise for you to understand more about Elixir and Phoenix :-).</p>
]]></content>
  </entry>
  
</feed>
