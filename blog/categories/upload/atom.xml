<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Upload | Learn Elixir Language]]></title>
  <link href="http://learnelixir.com/blog/categories/upload/atom.xml" rel="self"/>
  <link href="http://learnelixir.com/"/>
  <updated>2014-11-14T08:18:52+08:00</updated>
  <id>http://learnelixir.com/</id>
  <author>
    <name><![CDATA[Learn Elixir]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Image Upload in Phoenix Web App]]></title>
    <link href="http://learnelixir.com/blog/2014/10/23/image-upload-in-phoenix-web-app/"/>
    <updated>2014-10-23T06:46:02+08:00</updated>
    <id>http://learnelixir.com/blog/2014/10/23/image-upload-in-phoenix-web-app</id>
    <content type="html"><![CDATA[<p><strong>UPDATE</strong> on 30th Oct 14: I have updated this article in order to work with Phoenix framework version 0.5.0. Previously the Phoenix framework used in this article was 0.4.1
<hr/><br/>
I was trying to find on Internet a way to receive uploaded image and format the uploaded image in multiple styles for Elixir and Phoenix but unable to find one. Hence I decide to make a library to handle the image upload and blog about it. The end point that we would like to have in this article is the hardware gapplication that we have in the last article integrated with this library to allow user to upload a photo for each hardware. Here is the screenshot of the finished application:</p>

<p><img src='http://learnelixir.com/images/upload_image/final.png' width='800' height='394'/></p>

<!-- more -->

<ul>
<li>The source code is available on <a href="https://github.com/learnelixir/hardware-zone/tree/phoenix-0.5.0">https://github.com/learnelixir/hardware-zone/tree/phoenix-0.5.0</a></li>
<li>The updated application is also now lived at http://phoenix-hardware-zone.herokuapp.com</li>
</ul>

<p>In case you missed it, here is the URL linked to last article http://learnelixir.com/blog/2014/10/18/seven-restful-actions-in-phoenix-web-app/ which is an application that lets user do basic functionalities with hardware entity. What we are going to implement in this article is to allow user to upload a photo for each of the hardwares. Hence it will look more attractive to potential buyer. Let&#39;s start by adding the some more dependencies to the project.</p>

<h3>0 - Dependencies - More dependencies</h3>

<p>Add <code>plug</code> and <code>mogrify</code> library as extra depenecies inside your <code>mix.exs</code> file as of following:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">defp</span> <span class="n">deps</span> <span class="k">do</span>
    <span class="p">[</span>
      <span class="p">{</span><span class="ss">:phoenix</span><span class="p">,</span> <span class="s2">&quot;0.5.0&quot;</span><span class="p">},</span>
      <span class="p">{</span><span class="ss">:cowboy</span><span class="p">,</span> <span class="s2">&quot;~&gt; 1.0.0&quot;</span><span class="p">},</span>
      <span class="p">{</span><span class="ss">:postgrex</span><span class="p">,</span> <span class="s2">&quot;~&gt; 0.5&quot;</span><span class="p">},</span>
      <span class="p">{</span><span class="ss">:ecto</span><span class="p">,</span> <span class="s2">&quot;~&gt; 0.2.0&quot;</span><span class="p">},</span>
      <span class="p">{</span><span class="ss">:plug</span><span class="p">,</span> <span class="s2">&quot;~&gt; 0.7&quot;</span><span class="p">},</span>
      <span class="p">{</span><span class="ss">:mogrify</span><span class="p">,</span> <span class="s2">&quot;~&gt; 0.1&quot;</span><span class="p">}</span>
    <span class="p">]</span>
<span class="k">end</span>
</code></pre></div>
<ul>
<li><code>plug</code> will be used to retrieve the MIME types.</li>
<li><code>mogrify</code> will be used for image processing. It is actually ImageMagick wrapper.</li>
</ul>

<p>Then run <code>deps.get</code></p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>mix deps.get
</code></pre></div>
<h3>1 - Migration - More columns</h3>

<p>Now add 4 additional columns to the <code>hardware</code> model. The uploaded photo information will be captured using these fields:</p>

<ul>
<li><code>photo_file_name</code>: is used to store photo&#39;s file name.</li>
<li><code>photo_content_type</code>: is used to store photo&#39;s content type. </li>
<li><code>photo_file_size</code>: is used to store photo&#39;s file size in byte unit. </li>
<li><code>photo_updated_at</code>: is used to store the time stamp that photo last updated.</li>
</ul>

<p>To do this, we will need to generate another migration file by running this command from the terminal</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>mix ecto.gen.migration HardwareZone.Repo add_photo_to_hardware
</code></pre></div>
<p>Let open this newly generated migration file and add these 4 columns. In my case, it is <code>priv/repo/migrations/20141022230017_add_photo_to_hardware.exs</code>:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>vim priv/repo/migrations/20141022230017_add_photo_to_hardware.exs
</code></pre></div>
<p>and replace by the following code content:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">defmodule</span> <span class="nc">HardwareZone.Repo.Migrations.AddPhotoToHardware</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="nc">Ecto.Migration</span>

  <span class="kd">def</span> <span class="n">up</span> <span class="k">do</span>
    <span class="s2">&quot;ALTER TABLE hardwares </span><span class="err">\</span><span class="s2"></span>
<span class="s2">        ADD COLUMN photo_file_name varchar(255), </span><span class="err">\</span><span class="s2"></span>
<span class="s2">        ADD COLUMN photo_content_type varchar(255), </span><span class="err">\</span><span class="s2"></span>
<span class="s2">        ADD COLUMN photo_file_size integer, </span><span class="err">\</span><span class="s2"></span>
<span class="s2">        ADD COLUMN photo_updated_at timestamp;&quot;</span>
  <span class="k">end</span>

  <span class="kd">def</span> <span class="n">down</span> <span class="k">do</span>
    <span class="s2">&quot;ALTER TABLE hardwares </span><span class="err">\</span><span class="s2"></span>
<span class="s2">        DROP COLUMN photo_file_name, </span>
<span class="s2">        DROP COLUMN photo_content_type, </span>
<span class="s2">        DROP COLUMN photo_file_size, </span>
<span class="s2">        DROP COLUMN photo_updated_at;&quot;</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>Then from your command line, run the migration:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>mix ecto.migrate HardwareZone.Repo
</code></pre></div>
<p>In the last step in this section, you will need to specify these fields in the model so that it can be recognised by Ecto library. You can do this by editing <code>web/models/hardware.ex</code>:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>vim web/models/hardware.ex
</code></pre></div>
<p>and modify the schema <code>hardwares</code> like following:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="n">schema</span> <span class="s2">&quot;hardwares&quot;</span> <span class="k">do</span>
  <span class="n">field</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:string</span>
  <span class="n">field</span> <span class="ss">:description</span><span class="p">,</span> <span class="ss">:string</span>
  <span class="n">field</span> <span class="ss">:manufacturer</span><span class="p">,</span> <span class="ss">:string</span>
  <span class="n">field</span> <span class="ss">:sale_contact_number</span><span class="p">,</span> <span class="ss">:string</span>
  <span class="n">field</span> <span class="ss">:photo_file_name</span><span class="p">,</span> <span class="ss">:string</span>
  <span class="n">field</span> <span class="ss">:photo_file_size</span><span class="p">,</span> <span class="ss">:integer</span>
  <span class="n">field</span> <span class="ss">:photo_updated_at</span><span class="p">,</span> <span class="ss">:datetime</span>
  <span class="n">field</span> <span class="ss">:photo_content_type</span><span class="p">,</span> <span class="ss">:string</span>
<span class="k">end</span> 
</code></pre></div>
<p>Note that we have added into 4 extra fields here corresponding with the fields that we have added in the database earlier.</p>

<h3>2 - File Upload field in form view</h3>

<p>To let user choose a file from the form, we will need to add an upload field in our form. So let&#39;s go ahead and edit the hardware form:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ vim web/templates/hardwares/form.html.eex
</code></pre></div>
<p>then add in the following HTML code just below the <code>if @hardware.id do</code> condition block</p>
<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;form-group&quot;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;label</span> <span class="na">for=</span><span class="s">&quot;hardware[photo]&quot;</span><span class="nt">&gt;</span>Photo<span class="nt">&lt;/label&gt;</span>
  <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">&quot;file&quot;</span> <span class="na">name=</span><span class="s">&quot;hardware[photo]&quot;</span> <span class="na">class=</span><span class="s">&quot;form-control&quot;</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</code></pre></div>
<p>Now try to visit the new hardware page <a href="http://localhost:4000/hardwares/new">http://localhost:4000/hardwares/new</a>, select a random file and click save then check the server log. What you will see is the parameter as something similar to what is inside the below screenshot I took from my Mac:</p>

<p><img class="center" src="/images/upload<em>image/upload</em>image_terminal.png&#8221; width=&#8221;637&#8221; height=&#8221;269&#8221; title=&#8221;&#39;image&#39; &#39;images&#39;&#8221; ></p>

<p>Let&#39;s reformat the parameters for readable purpose:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">Parameters: %<span class="o">{</span>
  <span class="s2">&quot;hardware&quot;</span> <span class="o">=</span>&gt; %<span class="o">{</span>
    <span class="s2">&quot;description&quot;</span> <span class="o">=</span>&gt; <span class="s2">&quot;&quot;</span>, 
    <span class="s2">&quot;manufacturer&quot;</span> <span class="o">=</span>&gt; <span class="s2">&quot;&quot;</span>, 
    <span class="s2">&quot;name&quot;</span> <span class="o">=</span>&gt; <span class="s2">&quot;&quot;</span>, 
    <span class="s2">&quot;photo&quot;</span> <span class="o">=</span>&gt; %Plug.Upload<span class="o">{</span>
      content_type: <span class="s2">&quot;image/png&quot;</span>, 
      filename: <span class="s2">&quot;Screen Shot 2014-10-23 at 6.43.12 am.png&quot;</span>, 
      path: <span class="s2">&quot;/var/folders/jk/c2560ztn1394tl7c_67yx8900000gn/T//plug-1414/multipart-68820-690153&quot;</span>
    <span class="o">}</span>, 
    <span class="s2">&quot;sale_contact_number&quot;</span> <span class="o">=</span>&gt; <span class="s2">&quot;&quot;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>As you can see, the parameter photo has been formated and nicely and gave to us as <code>Plug.Upload</code> struct thank to phoenix framework. From here, we will only need to take in this struct, save and make a thumbnail out of this photo. Let&#39;s move on to next step to process this <code>Plug.Upload</code> struct in a library file.</p>

<h3>3 - Process <code>Plug.Upload</code> struct</h3>

<p>You can start by creating a library file and named it <code>up_plug.ex</code> and put in under <code>lib</code> folder:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>vim lib/up_plug.ex
</code></pre></div>
<p>and paste in the following initial code:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">defmodule</span> <span class="nc">UpPlug</span> <span class="k">do</span>
  <span class="kn">import</span> <span class="nc">Mogrify</span>
  <span class="kd">defstruct</span> <span class="ss">plug</span><span class="p">:</span> <span class="no">nil</span><span class="p">,</span> <span class="ss">model</span><span class="p">:</span> <span class="no">nil</span><span class="p">,</span> <span class="ss">attribute_name</span><span class="p">:</span> <span class="no">nil</span><span class="p">,</span> <span class="ss">styles</span><span class="p">:</span> <span class="p">%{}</span> 
<span class="k">end</span>
</code></pre></div>
<p>Here we have defined a <code>defmodule</code> named <code>UpPlug</code>, and at the same time we have defined it to be a struct by using the command <code>defstruct</code> on line 3 of the code. <code>defstruct</code> will enable us create <code>UnPlug</code> struct later with the attributes <code>plug</code>, <code>model</code>, <code>attribute_name</code> and <code>styles</code> witht corresponding default value specified on the same line. </p>

<p>To make our library solid and roboust, we also need a test file for it. Let&#39;s create <code>up_plug_test.exs</code> in <code>test</code> folder: </p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>vim <span class="nb">test</span>/up_plug_test.exs
</code></pre></div>
<p>with the following initial code:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">defmodule</span> <span class="nc">UpPlugTest</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="nc">ExUnit.Case</span>
  <span class="kn">import</span> <span class="nc">UpPlug</span>
<span class="k">end</span>
</code></pre></div>
<p>What we want to achieve are in this library can be seen below. And of course, it can be extended eventually to become a library that support uploading file. But for the scope of this article, let&#39;s just stick with the following requirements:</p>

<ul>
<li>Create a function which takes in a <code>UpPlug</code> struct argument containing the <code>Plug.Upload</code> struct, the model struct this upload belongs to, the name of the uploaded file attribute (i.e. in this case it is <code>photo</code>) and the styles and saves the uploaded file, at the same time created all the formatted photo based on the input <code>styles</code>. In code, I would love to have this function call:</li>
</ul>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="c1"># For processing uploaded file </span>
<span class="nc">UpPlug</span><span class="p">.</span><span class="n">process_upload_plug</span><span class="p">(</span>
  <span class="p">%</span><span class="nc">UpPlug</span><span class="p">{</span>
    <span class="ss">model</span><span class="p">:</span> <span class="p">%</span><span class="nc">Hardware</span><span class="p">{</span><span class="ss">id</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
    <span class="ss">plug</span><span class="p">:</span> <span class="p">%</span><span class="nc">Plug.Upload</span><span class="p">{</span>
      <span class="ss">filename</span><span class="p">:</span> <span class="s2">&quot;sample.png&quot;</span><span class="p">,</span>
      <span class="ss">path</span><span class="p">:</span> <span class="s2">&quot;...&quot;</span><span class="p">,</span>
      <span class="ss">content_type</span><span class="p">:</span> <span class="s2">&quot;image/png&quot;</span>
    <span class="p">},</span>
    <span class="ss">attribute_name</span><span class="p">:</span> <span class="ss">:photo</span><span class="p">,</span>
    <span class="ss">styles</span><span class="p">:</span> <span class="p">%{</span>
      <span class="ss">thumb</span><span class="p">:</span> <span class="s2">&quot;50x50&gt;&quot;</span><span class="p">,</span>
      <span class="ss">medium</span><span class="p">:</span> <span class="s2">&quot;120x120&gt;&quot;</span>
    <span class="p">}</span> 
  <span class="p">}</span> 
<span class="p">)</span>
</code></pre></div>
<ul>
<li><p>The file should be stored in the folder structure such that there are max 1,000 files in each folder. This is to maximize the performance of linux folder structure. If there are more than 1,000 files in a folder, the file retrieval will be slower. For this we will follow the structure that Paperclip library (https://github.com/thoughtbot/paperclip) defined, i.e. first file will be stored in the folder <code>000/000/001</code>, second file will be on <code>000/000/002</code>, and say the 1001st file will be stored in folder <code>000/001/001</code> and so on.</p></li>
<li><p>If the uploaded file is not an image file, we can simply store the file in the <code>original</code> subfolder of the folder mentioned above. </p></li>
<li><p>If the uploaded file is an image, we will let user specify styles attributed defined in <code>UpPlug</code> struct argument in order to generate different styles for the photo. For example, a sample of styles parameter is as following and when calling the process image function, it will create 3 folders under the folder structure that was mentioned above: <code>original</code> for storing the user uploaded original image, <code>medium</code> is for storing the <code>120x120&gt;</code> processed image and a <code>thumb</code> folder is for storing <code>50x50&gt;</code> processed image. </p></li>
</ul>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir">  <span class="p">%{</span> 
    <span class="ss">styles</span><span class="p">:</span> <span class="p">%{</span>
      <span class="ss">thumb</span><span class="p">:</span> <span class="s2">&quot;50x50&gt;&quot;</span>
      <span class="ss">medium</span><span class="p">:</span> <span class="s2">&quot;120x120&gt;&quot;</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div>
<ul>
<li>So let&#39;s say I upload a file called <code>sample.png</code> into model <code>HardwareZone.Hardware</code>, and I specify with 2 styles <code>thumb</code> and <code>medium</code>. After the upload process is completed, I should have 3 files stored at the following paths which are relative to the project path:</li>
</ul>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">priv/static/system/hardware_zone/hardware/photo/000/000/001/original/sample.png
priv/static/system/hardware_zone/hardware/photo/000/000/001/thumb/sample.png
priv/static/system/hardware_zone/hardware/photo/000/000/001/medium/sample.png
</code></pre></div>
<ul>
<li><p>The file is supposed to be stored in <code>priv/static</code> because that&#39;s the only place that the browser can access the file directly. In the same folder, you also can see the assets folder <code>css</code>, <code>images</code> and <code>js</code>.</p></li>
<li><p>The library should allow us to retrieve back the path and the URLs to the file for different formats for displaying purposes. The function can be envisioned as like following:</p></li>
</ul>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="nc">UpPlug</span><span class="p">.</span><span class="n">attachment_url_for</span><span class="p">(</span>
  <span class="p">%{</span><span class="nc">Hardware</span><span class="p">{</span>
    <span class="ss">id</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> 
    <span class="ss">photo_file_name</span><span class="p">:</span> <span class="s2">&quot;sample.png&quot;</span>
  <span class="p">},</span> <span class="ss">:photo</span><span class="p">,</span> <span class="ss">:thumb</span><span class="p">,</span> <span class="s2">&quot;/images/no_photo.png&quot;&quot;)</span>

<span class="err">#</span><span class="s2"> Arguments order:</span>
<span class="err">#</span><span class="s2"></span>
<span class="err">#</span><span class="s2"> - model struct</span>
<span class="err">#</span><span class="s2"> - attachment attribute name</span>
<span class="err">#</span><span class="s2"> - style (default is original)</span>
<span class="err">#</span><span class="s2"> - default_url (will be served when no image)</span>
</code></pre></div>
<p>With these in mind, let&#39;s create the first test case for this <code>UpPlug</code> library. But before that, we will need to create some sample data. Open your file <code>test/test_helper.exs</code></p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>vim <span class="nb">test</span>/test_helper.exs
</code></pre></div>
<p>and add in <code>SampleModel</code> struct at the end of the file. This will be the model which the uploaded photo is attached to:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">defmodule</span> <span class="nc">SampleModel</span> <span class="k">do</span>
  <span class="kd">defstruct</span> <span class="ss">id</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="ss">photo_file_size</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="err">\</span>
            <span class="ss">photo_file_name</span><span class="p">:</span> <span class="no">nil</span><span class="p">,</span> <span class="ss">photo_content_type</span><span class="p">:</span> <span class="no">nil</span><span class="p">,</span> <span class="ss">photo_updated_at</span><span class="p">:</span> <span class="no">nil</span> 
<span class="k">end</span>
</code></pre></div>
<p>Create a folder <code>sample_data</code> in your project folder:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>mkdir sample_data
</code></pre></div>
<p>Then copy files <code>samples.png</code> (<a href="https://raw.githubusercontent.com/learnelixir/hardware-zone/master/sample_data/sample.png">https://raw.githubusercontent.com/learnelixir/hardware-zone/master/sample_data/sample.png</a>) and <code>sample.pdf</code> (<a href="https://github.com/learnelixir/hardware-zone/raw/master/sample_data/sample.pdf">https://github.com/learnelixir/hardware-zone/raw/master/sample_data/sample.pdf</a>) into <code>sample_data</code> folder. You might want to change the path of these 2 sample files by modify the following code on line 7 and 12. Here is the <code>setup</code> callback in <code>test/up_plug_test.exs</code>:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="n">setup</span> <span class="k">do</span>
  <span class="p">{</span>
    <span class="ss">:ok</span><span class="p">,</span> <span class="err">\</span>
    <span class="ss">sample_image_plug</span><span class="p">:</span> <span class="p">%</span><span class="nc">Plug.Upload</span><span class="p">{</span> <span class="err">\</span>
      <span class="ss">content_type</span><span class="p">:</span> <span class="s2">&quot;image/png&quot;</span><span class="p">,</span> <span class="err">\</span>
      <span class="ss">filename</span><span class="p">:</span> <span class="s2">&quot;sample.png&quot;</span><span class="p">,</span> <span class="err">\</span>
      <span class="ss">path</span><span class="p">:</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="nc">Path</span><span class="p">.</span><span class="n">expand</span><span class="p">(</span><span class="s2">&quot;../&quot;</span><span class="p">,</span> <span class="bp">__DIR__</span><span class="p">)</span><span class="si">}</span><span class="s2">/sample_data/sample.png&quot;</span> <span class="err">\</span>
    <span class="p">},</span> <span class="err">\</span>
    <span class="ss">sample_document_plug</span><span class="p">:</span> <span class="p">%</span><span class="nc">Plug.Upload</span><span class="p">{</span> <span class="err">\</span>
      <span class="ss">content_type</span><span class="p">:</span> <span class="s2">&quot;application/pdf&quot;</span><span class="p">,</span> <span class="err">\</span>
      <span class="ss">filename</span><span class="p">:</span> <span class="s2">&quot;sample.pdf&quot;</span><span class="p">,</span> <span class="err">\</span>
      <span class="ss">path</span><span class="p">:</span>  <span class="s2">&quot;</span><span class="si">#{</span><span class="nc">Path</span><span class="p">.</span><span class="n">expand</span><span class="p">(</span><span class="s2">&quot;../&quot;</span><span class="p">,</span> <span class="bp">__DIR__</span><span class="p">)</span><span class="si">}</span><span class="s2">/sample_data/sample.pdf&quot;</span> <span class="err">\</span>
    <span class="p">},</span> <span class="err">\</span>
    <span class="ss">model_struct</span><span class="p">:</span> <span class="p">%</span><span class="nc">SampleModel</span><span class="p">{},</span> <span class="err">\</span>
    <span class="ss">photo_attribute_name</span><span class="p">:</span> <span class="ss">:photo</span><span class="p">,</span>
    <span class="ss">document_attribute_name</span><span class="p">:</span> <span class="ss">:spec</span>
  <span class="p">}</span>
<span class="k">end</span>

<span class="n">setup</span> <span class="n">context</span> <span class="k">do</span> 
  <span class="p">{</span>
    <span class="ss">:ok</span><span class="p">,</span> 
    <span class="nc">Map</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="ss">:up_plug</span><span class="p">,</span> <span class="p">%</span><span class="nc">UpPlug</span><span class="p">{</span> <span class="err">\</span>
      <span class="ss">plug</span><span class="p">:</span> <span class="n">context</span><span class="p">[</span><span class="ss">:sample_image_plug</span><span class="p">],</span> <span class="err">\</span>
      <span class="ss">model</span><span class="p">:</span> <span class="n">context</span><span class="p">[</span><span class="ss">:model_struct</span><span class="p">],</span>  <span class="err">\</span>
      <span class="ss">attribute_name</span><span class="p">:</span> <span class="n">context</span><span class="p">[</span><span class="ss">:photo_attribute_name</span><span class="p">],</span> <span class="err">\</span>
      <span class="ss">styles</span><span class="p">:</span> <span class="p">%{</span>
        <span class="ss">thumb</span><span class="p">:</span> <span class="s2">&quot;50x50&gt;&quot;</span><span class="p">,</span>
        <span class="ss">medium</span><span class="p">:</span> <span class="s2">&quot;120x120&gt;&quot;</span> 
      <span class="p">}</span>
    <span class="p">})</span> <span class="o">|&gt;</span>  
    <span class="nc">Map</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="ss">:document_up_plug</span><span class="p">,</span> <span class="p">%</span><span class="nc">UpPlug</span><span class="p">{</span> <span class="err">\</span>
      <span class="ss">plug</span><span class="p">:</span> <span class="n">context</span><span class="p">[</span><span class="ss">:sample_document_plug</span><span class="p">],</span> <span class="err">\</span>
      <span class="ss">model</span><span class="p">:</span> <span class="n">context</span><span class="p">[</span><span class="ss">:model_struct</span><span class="p">],</span>
      <span class="ss">attribute_name</span><span class="p">:</span> <span class="n">context</span><span class="p">[</span><span class="ss">:document_attribute_name</span><span class="p">]</span>
    <span class="p">})</span>
  <span class="p">}</span>
<span class="k">end</span>
</code></pre></div>
<ul>
<li>I have used <code>setup</code> callback function in <code>ExUnit</code> to define some testing data so that it can be kept reusing in all the test cases. The <code>context</code> need to start with <code>:ok</code> and following by a Map.</li>
<li>In addition, on line 20, we can use the <code>setup</code> callback again to define extra data based on what have already been defined in the earlier call of <code>setup</code>. </li>
<li>In order to use testing data, you will need to pass in <code>context</code> in each of your test as in the test case that we are going to write by using <code>context</code> as the second parameter in <code>test</code> function call.</li>
</ul>

<p>Now, let try <code>mix test</code> by first adding the first test case inside also inside <code>test/up_plug_test.exs</code>. For this test, we would like to check if <code>Plug.Upload</code> struct is an upload of an image:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="n">test</span> <span class="s2">&quot;is_image? returns true if upload file is image&quot;</span><span class="p">,</span> <span class="n">context</span> <span class="k">do</span>
  <span class="n">assert</span> <span class="n">is_image?</span><span class="p">(</span><span class="n">context</span><span class="p">[</span><span class="ss">:sample_image_plug</span><span class="p">])</span> <span class="o">==</span> <span class="no">true</span>
<span class="k">end</span>
</code></pre></div>
<p>Note that, <code>context[:sample_image_plug]</code> is the struct <code>Plug.Upload</code> that we have defined in the <code>setup</code> callback ealier.</p>

<p>Then let&#39;s run the test. From the command line, type in the following command:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">mix <span class="nb">test</span>
</code></pre></div>
<p>Apparently, when we run <code>mix test</code> it will be a failed case and give an error. This is because we have not written any code yet. We are now at the red stage (red stage as in TDD red, green, refactor). </p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">test</span>/hardware_zone_test.exs:5: warning: this check/guard will always yield the same result
<span class="nb">test</span>/plug_plug_test.exs:3: warning: unused import UpPlug
** <span class="o">(</span>CompileError<span class="o">)</span> <span class="nb">test</span>/plug_plug_test.exs:17: <span class="k">function</span> <span class="s1">&#39;is_image?&#39;</span>/1 undefined
    <span class="o">(</span>stdlib<span class="o">)</span> lists.erl:1336: :lists.foreach/2
        <span class="o">(</span>stdlib<span class="o">)</span> erl_eval.erl:657: :erl_eval.do_apply/6
</code></pre></div>
<p>Because of this error, let go to our <code>UpPlug</code> library and add the <code>is_image?</code> function:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>vim lib/up_plug.ex
</code></pre></div>
<p>and add in the following <code>is_image?</code> helper which always return <code>true</code>:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">def</span> <span class="n">is_image?</span><span class="p">(</span><span class="n">plug</span><span class="p">)</span> <span class="k">do</span>
  <span class="no">true</span>
<span class="k">end</span>
</code></pre></div>
<p>Run the test now by using <code>mix test</code> and it should pass</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">..

Finished in 0.05 seconds <span class="o">(</span>0.05s on load, 0.00s on tests<span class="o">)</span>
<span class="m">2</span> tests, <span class="m">0</span> failures
</code></pre></div>
<p>Add in another test case to test the a document file case for this <code>is_image?</code> function, but this time, let&#39;s use <code>refute</code> as a negative assertion</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="n">test</span> <span class="s2">&quot;is_image? returns false if upload file is not an image&quot;</span><span class="p">,</span> <span class="n">context</span> <span class="k">do</span>
  <span class="n">refute</span> <span class="n">is_image?</span><span class="p">(</span><span class="n">context</span><span class="p">[</span><span class="ss">:sample_document_plug</span><span class="p">])</span>
<span class="k">end</span>
</code></pre></div>
<p>Run the test again and expect it to fail because our <code>is_image?</code> function always return true. </p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">.

  1<span class="o">)</span> <span class="nb">test </span>is_image? returns <span class="nb">false </span><span class="k">if</span> upload file is not an image <span class="o">(</span>UpPlugTest<span class="o">)</span>
     <span class="nb">test</span>/up_plug_test.exs:25
     Assertion <span class="nv">with</span> <span class="o">==</span> failed
     code: is_image?<span class="o">(</span>context<span class="o">[</span>:sample_document_plug<span class="o">])</span> <span class="o">==</span> <span class="nb">false</span>
<span class="nb">     </span>lhs:  <span class="nb">true</span>
<span class="nb">     </span>rhs:  <span class="nb">false</span>
<span class="nb">     </span>stacktrace:
       <span class="nb">test</span>/up_plug_test.exs:26

.

Finished in 0.05 seconds <span class="o">(</span>0.05s on load, 0.00s on tests<span class="o">)</span>
<span class="m">3</span> tests, <span class="m">1</span> failures
</code></pre></div>
<p>It&#39;s time to fix the <code>is_image?</code> function that we created ealier by do a real check on the image&#39;s MIME type:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">def</span> <span class="n">is_image?</span><span class="p">(</span><span class="n">plug</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">content_type</span> <span class="p">=</span> <span class="n">plug</span><span class="p">.</span><span class="n">content_type</span>
  <span class="n">image_mimes</span> <span class="p">=</span> <span class="p">[</span> 
    <span class="nc">Plug.MIME</span><span class="p">.</span><span class="n">type</span><span class="p">(</span><span class="s2">&quot;png&quot;</span><span class="p">),</span> 
    <span class="nc">Plug.MIME</span><span class="p">.</span><span class="n">type</span><span class="p">(</span><span class="s2">&quot;jpg&quot;</span><span class="p">),</span> 
    <span class="nc">Plug.MIME</span><span class="p">.</span><span class="n">type</span><span class="p">(</span><span class="s2">&quot;gif&quot;</span><span class="p">)</span>
  <span class="p">]</span>   
  <span class="nc">Enum</span><span class="p">.</span><span class="n">find_index</span><span class="p">(</span><span class="n">image_mimes</span><span class="p">,</span> <span class="k">fn</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">x</span> <span class="o">==</span> <span class="n">content_type</span> <span class="k">end</span><span class="p">)</span> <span class="o">!=</span> <span class="no">nil</span> 
<span class="k">end</span> 
</code></pre></div>
<p>Note that <code>Plug.MIME</code> is from <code>plug</code> library. Run the test again and every thing should pass now:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">...

Finished in 0.05 seconds <span class="o">(</span>0.05s on load, 0.00s on tests<span class="o">)</span>
<span class="m">3</span> tests, <span class="m">0</span> failures
</code></pre></div>
<p>Up to this point, let&#39;s list down all the requirements before starting to implement, then eventually write the content of all these specs and the codes to pass the spec. Below is the list of all the requirements which have been trasnformed into test spec for this upload module. It&#39;s not an exhausted list yet, but you are encouraged to keep adding on more test cases when there is a need. It is good practice to write all the specs down in this kind of format so that you are aware of all the requirements that need to be implemented: </p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="c1"># test/up_plug_test.exs</span>

<span class="n">test</span> <span class="s2">&quot;returns 000/000/001 from id_partition with id 1&quot;</span> <span class="ss">do</span><span class="p">:</span> <span class="ss">:pending</span>
<span class="n">test</span> <span class="s2">&quot;returns 000/120/501 from id_partition with id 120501&quot;</span> <span class="ss">do</span><span class="p">:</span> <span class="ss">:pending</span> 
<span class="n">test</span> <span class="s2">&quot;assigns photo_updated_at attribute after saving the photo&quot;</span><span class="p">,</span> <span class="ss">do</span><span class="p">:</span> <span class="ss">:pending</span>
<span class="n">test</span> <span class="s2">&quot;assigns photo_content_type attribute after saving the photo&quot;</span><span class="p">,</span> <span class="ss">do</span><span class="p">:</span> <span class="ss">:pending</span>
<span class="n">test</span> <span class="s2">&quot;assigns photo_file_name attribute after saving the photo&quot;</span><span class="p">,</span> <span class="ss">do</span><span class="p">:</span> <span class="ss">:pending</span>
<span class="n">test</span> <span class="s2">&quot;replaces special character in file name with _&quot;</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="ss">do</span><span class="p">:</span> <span class="ss">:pending</span>
<span class="n">test</span> <span class="s2">&quot;assigns photo_file_size attribute after saving the photo&quot;</span><span class="p">,</span> <span class="ss">do</span><span class="p">:</span> <span class="ss">:pending</span>
<span class="n">test</span> <span class="s2">&quot;stores uploaded image in original folder&quot;</span><span class="p">,</span> <span class="ss">do</span><span class="p">:</span> <span class="ss">:pending</span>
<span class="n">test</span> <span class="s2">&quot;stores extra styled images in corresponding folder&quot;</span><span class="p">,</span> <span class="ss">do</span><span class="p">:</span> <span class="ss">:pending</span>
<span class="n">test</span> <span class="s2">&quot;stores uploaded document in original folder&quot;</span><span class="p">,</span> <span class="ss">do</span><span class="p">:</span> <span class="ss">:pending</span>
<span class="n">test</span> <span class="s2">&quot;returns correct url for original image&quot;</span><span class="p">,</span> <span class="ss">do</span><span class="p">:</span> <span class="ss">:pending</span>
<span class="n">test</span> <span class="s2">&quot;returns correct url for a styled image&quot;</span><span class="p">,</span> <span class="ss">do</span><span class="p">:</span> <span class="ss">:pending</span>
</code></pre></div>
<p>At the time I wrote this article, <code>ExUnit</code> does not have a way to specify a test case as a pending case, so what I did was using <code>do: :pending</code>. However I really hope that <code>ExUnit</code> will support pending case soon as it&#39;s important to know what are the cases that are still pending when running all the tests. </p>

<p>Now, if you run the command <code>mix test</code> now, you should see everything passed.</p>

<p>At this stage, I would like to fast forward by just showing the test code and follow by showing the code implementation. Let&#39;s continue with specifying the test for <code>id_partition</code> function.</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="c1"># test/up_plug_test.exs</span>

<span class="n">test</span> <span class="s2">&quot;returns 000/000/001 for id_partition call with id 1&quot;</span> <span class="k">do</span>
  <span class="n">assert</span> <span class="n">id_partition</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;000/000/001&quot;</span>
<span class="k">end</span>

<span class="n">test</span> <span class="s2">&quot;returns 000/120/501 for id_partition call with id 120501&quot;</span> <span class="k">do</span>
  <span class="n">assert</span> <span class="n">id_partition</span><span class="p">(</span><span class="mi">120501</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;000/120/501&quot;</span>
<span class="k">end</span>
</code></pre></div>
<p>To make these tests pass, the implementation for <code>id_partition</code> is as following:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="c1"># lib/up_plug.ex</span>

<span class="kd">def</span> <span class="n">id_partition</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="k">do</span>
  <span class="k">if</span> <span class="n">id</span> <span class="o">!=</span> <span class="no">nil</span> <span class="k">do</span>
    <span class="n">formatted_id</span> <span class="p">=</span> <span class="ss">:io_lib</span><span class="p">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;~9..0B&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">id</span><span class="p">])</span>  <span class="o">|&gt;</span> <span class="nc">List</span><span class="p">.</span><span class="n">flatten</span> <span class="o">|&gt;</span> <span class="n">to_string</span> 
    <span class="nc">Regex</span><span class="p">.</span><span class="n">scan</span><span class="p">(</span><span class="sx">~r/</span><span class="se">\d</span><span class="sx">{3}/</span><span class="p">,</span> <span class="n">formatted_id</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="nc">List</span><span class="p">.</span><span class="n">flatten</span> <span class="o">|&gt;</span> <span class="nc">Enum</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="s2">&quot;&quot;</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p><code>id_partition</code> function is defined to convert an id into the 3 layer folder structure. Line 4 is the code to convert an id to a string of 9 characters. For instance, 1025 will be transformed to <code>000001025</code>. Then on line 5, this string will be split into 3 segments, each segment has 3 characters, then are joined by <code>/</code> to form <code>000/001/025</code>.</p>

<p>Next, we will need put in test code for testing the proper assignments for the 4 attributes: <code>photo_file_name</code>, <code>photo_file_size</code>, <code>photo_content_type</code> and <code>photo_updated_at</code></p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="c1"># test/up_plug_test.exs</span>

<span class="n">test</span> <span class="s2">&quot;assigns photo_updated_at attribute after saving the photo&quot;</span><span class="p">,</span> <span class="n">context</span> <span class="k">do</span>
  <span class="n">model</span> <span class="p">=</span> <span class="n">process_upload_plug</span><span class="p">(</span><span class="n">context</span><span class="p">[</span><span class="ss">:up_plug</span><span class="p">])</span> 
  <span class="n">assert</span> <span class="n">model</span><span class="p">.</span><span class="n">photo_updated_at</span><span class="p">.</span><span class="n">__struct__</span> <span class="o">==</span> <span class="nc">Ecto.DateTime</span>
<span class="k">end</span>

<span class="n">test</span> <span class="s2">&quot;assigns photo_content_type attribute after saving the photo&quot;</span><span class="p">,</span> <span class="n">context</span> <span class="k">do</span>
  <span class="n">model</span> <span class="p">=</span> <span class="n">process_upload_plug</span><span class="p">(</span><span class="n">context</span><span class="p">[</span><span class="ss">:up_plug</span><span class="p">])</span>
  <span class="n">assert</span> <span class="n">model</span><span class="p">.</span><span class="n">photo_content_type</span> <span class="o">==</span> <span class="n">context</span><span class="p">[</span><span class="ss">:sample_image_plug</span><span class="p">].</span><span class="n">content_type</span> 
<span class="k">end</span>

<span class="n">test</span> <span class="s2">&quot;assigns photo_file_name attribute after saving the photo&quot;</span><span class="p">,</span> <span class="n">context</span> <span class="k">do</span>
  <span class="n">model</span> <span class="p">=</span> <span class="n">process_upload_plug</span><span class="p">(</span><span class="n">context</span><span class="p">[</span><span class="ss">:up_plug</span><span class="p">])</span>
  <span class="n">assert</span> <span class="n">model</span><span class="p">.</span><span class="n">photo_file_name</span> <span class="o">==</span> <span class="n">context</span><span class="p">[</span><span class="ss">:sample_image_plug</span><span class="p">].</span><span class="n">filename</span>
<span class="k">end</span>

<span class="n">test</span> <span class="s2">&quot;replaces special character in file name with _&quot;</span><span class="p">,</span> <span class="n">context</span> <span class="k">do</span>
  <span class="n">new_plug</span> <span class="p">=</span> <span class="nc">Map</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">context</span><span class="p">[</span><span class="ss">:up_plug</span><span class="p">].</span><span class="n">plug</span><span class="p">,</span> <span class="ss">:filename</span><span class="p">,</span> <span class="s2">&quot;a&amp;b+c?d;e@f&gt;g&lt;h|i^j</span><span class="err">#</span><span class="s2">k%l\\m,n=o.png&quot;</span><span class="p">)</span>
  <span class="n">new_up_plug</span> <span class="p">=</span> <span class="nc">Map</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">context</span><span class="p">[</span><span class="ss">:up_plug</span><span class="p">],</span> <span class="ss">:plug</span><span class="p">,</span> <span class="n">new_plug</span><span class="p">)</span>
  <span class="n">model</span> <span class="p">=</span> <span class="n">process_upload_plug</span><span class="p">(</span><span class="n">new_up_plug</span><span class="p">)</span>
  <span class="n">assert</span> <span class="n">model</span><span class="p">.</span><span class="n">photo_file_name</span> <span class="o">==</span> <span class="s2">&quot;a_b_c_d_e_f_g_h_i_j_k_l_m_n_o.png&quot;</span>
<span class="k">end</span>

<span class="n">test</span> <span class="s2">&quot;assigns the photo_file_size attribute after saving the photo&quot;</span><span class="p">,</span> <span class="n">context</span> <span class="k">do</span>
  <span class="n">model</span> <span class="p">=</span> <span class="n">process_upload_plug</span><span class="p">(</span><span class="n">context</span><span class="p">[</span><span class="ss">:up_plug</span><span class="p">])</span>
  <span class="n">assert</span> <span class="n">model</span><span class="p">.</span><span class="n">photo_file_size</span> <span class="o">==</span> <span class="mi">917350</span> 
<span class="k">end</span>
</code></pre></div>
<p>Just one thing to highlight in the above code is on the third test case (line 16 - 21), we enforce the system to convert all the special characters to underscore (<code>_</code>) so that when we generate the URL for displaying the photo, it will be a well-formatted URL. </p>

<p>And here comes the code to pass the above cases:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="c1"># lib/up_plug.ex</span>

<span class="kd">def</span> <span class="n">process_upload_plug</span><span class="p">(</span><span class="n">up_plug</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">model</span> <span class="p">=</span> <span class="n">assign_file_information</span><span class="p">(</span><span class="n">up_plug</span><span class="p">)</span>
  <span class="n">up_plug</span> <span class="p">=</span> <span class="nc">Map</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">up_plug</span><span class="p">,</span> <span class="ss">:model</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>
  <span class="n">post_process_file</span><span class="p">(</span><span class="n">up_plug</span><span class="p">)</span>
  <span class="n">up_plug</span><span class="p">.</span><span class="n">model</span>
<span class="k">end</span>

<span class="kd">def</span> <span class="n">assign_file_information</span><span class="p">(</span><span class="n">up_plug</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">plug</span> <span class="p">=</span> <span class="n">up_plug</span><span class="p">.</span><span class="n">plug</span>
  <span class="n">model</span> <span class="p">=</span> <span class="n">up_plug</span><span class="p">.</span><span class="n">model</span>
  <span class="n">model</span> <span class="p">=</span> <span class="nc">Map</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="err">\</span>
                  <span class="nc">String</span><span class="p">.</span><span class="n">to_atom</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">#{</span><span class="n">up_plug</span><span class="p">.</span><span class="n">attribute_name</span><span class="si">}</span><span class="s2">_updated_at&quot;</span><span class="p">),</span> <span class="nc">Ecto.DateTime</span><span class="p">.</span><span class="n">utc</span><span class="p">)</span>
  <span class="n">model</span> <span class="p">=</span> <span class="nc">Map</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="err">\</span>
                  <span class="nc">String</span><span class="p">.</span><span class="n">to_atom</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">#{</span><span class="n">up_plug</span><span class="p">.</span><span class="n">attribute_name</span><span class="si">}</span><span class="s2">_content_type&quot;</span><span class="p">),</span> <span class="n">content_type</span><span class="p">(</span><span class="n">plug</span><span class="p">))</span>
  <span class="n">model</span> <span class="p">=</span> <span class="nc">Map</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="err">\</span>
                  <span class="nc">String</span><span class="p">.</span><span class="n">to_atom</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">#{</span><span class="n">up_plug</span><span class="p">.</span><span class="n">attribute_name</span><span class="si">}</span><span class="s2">_file_name&quot;</span><span class="p">),</span> <span class="n">file_name</span><span class="p">(</span><span class="n">plug</span><span class="p">))</span>
  <span class="n">model</span> <span class="p">=</span> <span class="nc">Map</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="err">\</span>
                  <span class="nc">String</span><span class="p">.</span><span class="n">to_atom</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">#{</span><span class="n">up_plug</span><span class="p">.</span><span class="n">attribute_name</span><span class="si">}</span><span class="s2">_file_size&quot;</span><span class="p">),</span> <span class="n">size</span><span class="p">(</span><span class="n">plug</span><span class="p">))</span>
  <span class="n">model</span> 
<span class="k">end</span>

<span class="kd">def</span> <span class="n">size</span><span class="p">(</span><span class="n">plug</span><span class="p">)</span> <span class="k">do</span>
  <span class="nc">File</span><span class="p">.</span><span class="n">stat!</span><span class="p">(</span><span class="n">plug</span><span class="p">.</span><span class="n">path</span><span class="p">).</span><span class="n">size</span>
<span class="k">end</span>

<span class="kd">def</span> <span class="n">content_type</span><span class="p">(</span><span class="n">plug</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">plug</span><span class="p">.</span><span class="n">content_type</span>
<span class="k">end</span>

<span class="kd">def</span> <span class="n">file_name</span><span class="p">(</span><span class="n">plug</span><span class="p">)</span> <span class="k">do</span>
  <span class="nc">Regex</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="sx">~r/[&amp;$+,\/:;=?@&lt;&gt;\[\]\{\}\|\\\^~%</span><span class="err">#</span><span class="sx"> ]/</span><span class="p">,</span> <span class="n">plug</span><span class="p">.</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span>
<span class="k">end</span>

<span class="kd">def</span> <span class="n">post_process_file</span><span class="p">(</span><span class="n">up_plug</span><span class="p">)</span> <span class="k">do</span>
  <span class="c1"># TODO</span>
<span class="k">end</span>
</code></pre></div>
<p>As you can see, the actual attribute assignments are done on function <code>assign_file_information</code>. Next, these are tests for checking that the images are stored in the proper folders:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="c1"># test/up_plug_test.exs</span>

<span class="n">test</span> <span class="s2">&quot;stores uploaded image in original folder&quot;</span><span class="p">,</span> <span class="n">context</span> <span class="k">do</span>
  <span class="n">process_upload_plug</span><span class="p">(</span><span class="n">context</span><span class="p">[</span><span class="ss">:up_plug</span><span class="p">])</span>
  <span class="n">expected_original_file_path</span> <span class="p">=</span> <span class="err">\</span>
    <span class="s2">&quot;</span><span class="si">#{</span><span class="nc">Mix.Project</span><span class="p">.</span><span class="n">app_path</span><span class="si">}</span><span class="s2">/priv/static/system/sample_model/photo/000/000/001/original/sample.png&quot;</span>
  <span class="n">assert</span> <span class="nc">File</span><span class="p">.</span><span class="n">exists?</span><span class="p">(</span><span class="n">expected_original_file_path</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">test</span> <span class="s2">&quot;stores extra styled images in corresponding folder&quot;</span><span class="p">,</span> <span class="n">context</span> <span class="k">do</span>
  <span class="n">process_upload_plug</span><span class="p">(</span><span class="n">context</span><span class="p">[</span><span class="ss">:up_plug</span><span class="p">])</span>
  <span class="n">expected_thumb_file_path</span> <span class="p">=</span> <span class="err">\</span>
    <span class="s2">&quot;</span><span class="si">#{</span><span class="nc">Mix.Project</span><span class="p">.</span><span class="n">app_path</span><span class="si">}</span><span class="s2">/priv/static/system/sample_model/photo/000/000/001/thumb/sample.png&quot;</span>
  <span class="n">assert</span> <span class="nc">File</span><span class="p">.</span><span class="n">exists?</span><span class="p">(</span><span class="n">expected_thumb_file_path</span><span class="p">)</span>

  <span class="n">expected_medium_file_path</span> <span class="p">=</span> <span class="err">\</span>
    <span class="s2">&quot;</span><span class="si">#{</span><span class="nc">Mix.Project</span><span class="p">.</span><span class="n">app_path</span><span class="si">}</span><span class="s2">/priv/static/system/sample_model/photo/000/000/001/medium/sample.png&quot;</span>
  <span class="n">assert</span> <span class="nc">File</span><span class="p">.</span><span class="n">exists?</span><span class="p">(</span><span class="n">expected_medium_file_path</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">test</span> <span class="s2">&quot;stores uploaded document in original folder&quot;</span><span class="p">,</span> <span class="n">context</span> <span class="k">do</span>
  <span class="n">process_upload_plug</span><span class="p">(</span><span class="n">context</span><span class="p">[</span><span class="ss">:document_up_plug</span><span class="p">])</span>
  <span class="n">expected_original_file_path</span> <span class="p">=</span> <span class="err">\</span>
    <span class="s2">&quot;</span><span class="si">#{</span><span class="nc">Mix.Project</span><span class="p">.</span><span class="n">app_path</span><span class="si">}</span><span class="s2">/priv/static/system/sample_model/spec/000/000/001/original/sample.pdf&quot;</span>
  <span class="n">assert</span> <span class="nc">File</span><span class="p">.</span><span class="n">exists?</span><span class="p">(</span><span class="n">expected_original_file_path</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div>
<p>And for the tests above to pass, we will need to implement the function <code>post_process_file</code> as shown below:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="c1"># lib/up_plug.ex</span>

<span class="kd">def</span> <span class="n">post_process_file</span><span class="p">(</span><span class="n">up_plug</span><span class="p">)</span> <span class="k">do</span>
  <span class="k">if</span> <span class="n">up_plug</span><span class="p">.</span><span class="n">model</span><span class="p">.</span><span class="n">id</span> <span class="k">do</span>
    <span class="n">attachment_directory_path</span> <span class="p">=</span> <span class="err">\</span>
      <span class="n">attachment_container_absolute_path</span><span class="p">(</span><span class="n">up_plug</span><span class="p">.</span><span class="n">model</span><span class="p">,</span> <span class="n">up_plug</span><span class="p">.</span><span class="n">attribute_name</span><span class="p">)</span>
    <span class="nc">File</span><span class="p">.</span><span class="n">rm_rf</span><span class="p">(</span><span class="n">attachment_directory_path</span><span class="p">)</span>
    <span class="nc">File</span><span class="p">.</span><span class="n">mkdir_p</span><span class="p">(</span><span class="n">attachment_directory_path</span><span class="p">)</span>
    <span class="n">store_original_file</span><span class="p">(</span><span class="n">up_plug</span><span class="p">,</span> <span class="n">attachment_directory_path</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">is_image?</span><span class="p">(</span><span class="n">up_plug</span><span class="p">.</span><span class="n">plug</span><span class="p">)</span> <span class="k">do</span>
      <span class="n">post_process_for_other_styles</span><span class="p">(</span><span class="n">up_plug</span><span class="p">,</span> <span class="n">attachment_directory_path</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="kd">def</span> <span class="n">store_original_file</span><span class="p">(</span><span class="n">up_plug</span><span class="p">,</span> <span class="n">attachment_directory_path</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">original_file_destination</span> <span class="p">=</span> <span class="nc">Enum</span><span class="p">.</span><span class="n">join</span><span class="p">(</span> <span class="err">\</span>
      <span class="p">[</span><span class="n">attachment_directory_path</span><span class="p">,</span> <span class="s2">&quot;original&quot;</span><span class="p">],</span> <span class="s2">&quot;/&quot;</span><span class="p">)</span>
  <span class="nc">File</span><span class="p">.</span><span class="n">mkdir_p</span><span class="p">(</span><span class="n">original_file_destination</span><span class="p">)</span>
  <span class="nc">File</span><span class="p">.</span><span class="n">copy</span><span class="p">(</span><span class="n">up_plug</span><span class="p">.</span><span class="n">plug</span><span class="p">.</span><span class="n">path</span><span class="p">,</span> <span class="nc">Enum</span><span class="p">.</span><span class="n">join</span><span class="p">(</span> <span class="err">\</span>
    <span class="p">[</span><span class="n">original_file_destination</span><span class="p">,</span> <span class="n">file_name</span><span class="p">(</span><span class="n">up_plug</span><span class="p">.</span><span class="n">plug</span><span class="p">)],</span> <span class="s2">&quot;/&quot;</span><span class="p">),</span> <span class="ss">:infinity</span><span class="p">)</span>
<span class="k">end</span>

<span class="kd">def</span> <span class="n">post_process_for_other_styles</span><span class="p">(</span><span class="n">up_plug</span><span class="p">,</span> <span class="n">attachment_directory_path</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">styles</span> <span class="p">=</span> <span class="n">up_plug</span><span class="p">.</span><span class="n">styles</span>
  <span class="k">if</span> <span class="n">styles</span> <span class="o">!=</span> <span class="no">nil</span> <span class="k">do</span>
    <span class="nc">Enum</span><span class="p">.</span><span class="n">each</span> <span class="n">styles</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">post_process_for_style</span><span class="p">(</span><span class="ni">&amp;1</span><span class="p">,</span> <span class="n">up_plug</span><span class="p">,</span> <span class="n">attachment_directory_path</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="kd">def</span> <span class="n">post_process_for_style</span><span class="p">({</span><span class="n">style_name</span><span class="p">,</span> <span class="n">style_size</span><span class="p">},</span> <span class="n">up_plug</span><span class="p">,</span> <span class="n">attachment_directory_path</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">saved_file_name</span> <span class="p">=</span> <span class="n">file_name</span><span class="p">(</span><span class="n">up_plug</span><span class="p">.</span><span class="n">plug</span><span class="p">)</span>
  <span class="n">original_file_path</span> <span class="p">=</span> <span class="nc">Enum</span><span class="p">.</span><span class="n">join</span><span class="p">(</span> <span class="err">\</span>
      <span class="p">[</span><span class="n">attachment_directory_path</span><span class="p">,</span> <span class="s2">&quot;original&quot;</span><span class="p">,</span> <span class="n">saved_file_name</span><span class="p">],</span> <span class="s2">&quot;/&quot;</span><span class="p">)</span>
  <span class="n">styled_file_destination</span> <span class="p">=</span> <span class="nc">Enum</span><span class="p">.</span><span class="n">join</span><span class="p">(</span> <span class="err">\</span>
      <span class="p">[</span><span class="n">attachment_directory_path</span><span class="p">,</span> <span class="n">style_name</span><span class="p">],</span> <span class="s2">&quot;/&quot;</span><span class="p">)</span>
  <span class="nc">File</span><span class="p">.</span><span class="n">mkdir_p</span><span class="p">(</span><span class="n">styled_file_destination</span><span class="p">)</span>
  <span class="n">open</span><span class="p">(</span><span class="n">original_file_path</span><span class="p">)</span> 
    <span class="o">|&gt;</span> <span class="n">copy</span> 
    <span class="o">|&gt;</span> <span class="n">resize</span><span class="p">(</span><span class="n">style_size</span><span class="p">)</span> 
    <span class="o">|&gt;</span> <span class="n">save</span><span class="p">(</span><span class="nc">Enum</span><span class="p">.</span><span class="n">join</span><span class="p">([</span><span class="n">styled_file_destination</span><span class="p">,</span> <span class="n">saved_file_name</span><span class="p">],</span> <span class="s2">&quot;/&quot;</span><span class="p">))</span>
<span class="k">end</span>

<span class="kd">def</span> <span class="n">attachment_container_relative_path</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">attribute_name</span><span class="p">)</span> <span class="k">do</span>
  <span class="nc">Enum</span><span class="p">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;system&quot;</span><span class="p">,</span> <span class="err">\</span>
      <span class="nc">Mix.Utils</span><span class="p">.</span><span class="n">underscore</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="n">__struct__</span><span class="p">),</span> <span class="err">\</span>
      <span class="n">attribute_name</span><span class="p">,</span> <span class="err">\</span>
      <span class="n">id_partition</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="n">id</span><span class="p">)],</span> <span class="s2">&quot;/&quot;</span><span class="p">)</span>
<span class="k">end</span>

<span class="kd">def</span> <span class="n">attachment_container_absolute_path</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">attribute_name</span><span class="p">)</span> <span class="k">do</span>
  <span class="nc">Enum</span><span class="p">.</span><span class="n">join</span><span class="p">([</span><span class="nc">Mix.Project</span><span class="p">.</span><span class="n">app_path</span><span class="p">,</span> <span class="s2">&quot;/priv/static&quot;</span><span class="p">,</span> 
      <span class="n">attachment_container_relative_path</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">attribute_name</span><span class="p">)],</span> <span class="s2">&quot;/&quot;</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div>
<ul>
<li><p>We first define the <code>post_process_file</code> function. In this function, we first check for the model id, then generate the target directory where the uploaded file will be copied into - <code>attachment_directory_path</code> (for example, id 201 will yield <code>&lt;path to your project&gt;/priv/static/system/hardware_zone/hardware/phot/000/000/201</code>). We then delete that folder and create again to make sure all the folder is clean. Then we copy the original uploaded file into the <code>original</code> folder under the generated folder path. This happens inside <code>store_original_file</code> function call. Then we check if the uploaded file is an image, then we will process with other styles of the uploaded file.</p></li>
<li><p>From line 36 to 39, we are using <code>mogrify</code> library to <code>open</code> the image, <code>copy</code>, <code>resize</code> and then save the resized image in the destination folder that are computed ealier. It is a very natural flow of converting an image file, thank to pipe Elixir operator <code>|&gt;</code>. The <code>mogrify</code> library has done a great job here by managing combining the pipe operator and the ImageMagick itself.</p></li>
</ul>

<p>And finally, here the test code to check if the generated URL for the uploaded images are returned correctly</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="c1"># test/up_plug_test.exs</span>

<span class="n">test</span> <span class="s2">&quot;returns correct url for original image&quot;</span><span class="p">,</span> <span class="n">context</span> <span class="k">do</span>
  <span class="n">model</span> <span class="p">=</span> <span class="n">process_upload_plug</span><span class="p">(</span><span class="n">context</span><span class="p">[</span><span class="ss">:up_plug</span><span class="p">])</span>
  <span class="n">assert</span> <span class="n">attachment_url_for</span><span class="p">(</span> <span class="err">\</span>
      <span class="n">model</span><span class="p">,</span> <span class="err">\</span>
      <span class="n">context</span><span class="p">[</span><span class="ss">:photo_attribute_name</span><span class="p">])</span> <span class="err">\</span>
    <span class="o">==</span> <span class="s2">&quot;/system/sample_model/photo/000/000/001/original/sample.png&quot;</span>
<span class="k">end</span>

<span class="n">test</span> <span class="s2">&quot;returns correct url for a styled image&quot;</span><span class="p">,</span> <span class="n">context</span> <span class="k">do</span>
  <span class="n">model</span> <span class="p">=</span> <span class="n">process_upload_plug</span><span class="p">(</span><span class="n">context</span><span class="p">[</span><span class="ss">:up_plug</span><span class="p">])</span>
  <span class="n">assert</span> <span class="n">attachment_url_for</span><span class="p">(</span> <span class="err">\</span>
      <span class="n">model</span><span class="p">,</span> <span class="err">\</span>
      <span class="n">context</span><span class="p">[</span><span class="ss">:photo_attribute_name</span><span class="p">],</span> <span class="err">\</span>
      <span class="ss">:thumb</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;/system/sample_model/photo/000/000/001/thumb/sample.png&quot;</span>

<span class="k">end</span>
</code></pre></div>
<p>And here is the corresponding implementation to pass these above test in <code>lib/up_plug.ex</code></p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="c1"># lib/up_plug.ex</span>

<span class="kd">def</span> <span class="n">attachment_url_for</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">attribute_name</span><span class="p">,</span> <span class="n">style</span> <span class="p">\\</span> <span class="ss">:original</span><span class="p">,</span> <span class="n">default_url</span> <span class="p">\\</span> <span class="no">nil</span> <span class="p">)</span> <span class="k">do</span>
  <span class="n">style</span> <span class="p">=</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">style</span><span class="si">}</span><span class="s2">&quot;</span>
  <span class="n">container_relative_path</span> <span class="p">=</span> <span class="n">attachment_container_relative_path</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">attribute_name</span><span class="p">)</span>
  <span class="n">container_absolute_path</span> <span class="p">=</span> <span class="n">attachment_container_absolute_path</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">attribute_name</span><span class="p">)</span>
  <span class="n">stored_file_name</span> <span class="p">=</span> <span class="nc">Map</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="nc">String</span><span class="p">.</span><span class="n">to_atom</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">#{</span><span class="n">attribute_name</span><span class="si">}</span><span class="s2">_file_name&quot;</span><span class="p">))</span> 

  <span class="n">target_file</span> <span class="p">=</span> <span class="nc">Enum</span><span class="p">.</span><span class="n">join</span><span class="p">([</span><span class="n">container_absolute_path</span><span class="p">,</span> <span class="n">style</span><span class="p">,</span> <span class="n">stored_file_name</span><span class="p">],</span> <span class="s2">&quot;/&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nc">File</span><span class="p">.</span><span class="n">exists?</span><span class="p">(</span><span class="n">target_file</span><span class="p">)</span> <span class="k">do</span>
    <span class="nc">Enum</span><span class="p">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">container_relative_path</span><span class="p">,</span> <span class="n">style</span><span class="p">,</span> <span class="n">stored_file_name</span><span class="p">],</span> <span class="s2">&quot;/&quot;</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="n">default_url</span> 
  <span class="k">end</span>
<span class="k">end</span>

<span class="kd">def</span> <span class="n">attachment_exist?</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">attribute_name</span><span class="p">)</span> <span class="k">do</span>
  <span class="nc">File</span><span class="p">.</span><span class="n">exists?</span><span class="p">(</span><span class="n">attachment_container_relative_path</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">attribute_name</span><span class="p">))</span>
<span class="k">end</span>
</code></pre></div>
<p>As you can see, the code is pretty straight forward. The program again tries the find the absolute path to the file and check if the file really exists. It it does, we will join the relative path (<code>/system/hardware_zone/hardware/photo/000/000/010/:style/</code>) with its stored file name. This link can be then accessed directly from the web browser.</p>

<p>That&#39;s all for this library. Let&#39;s move on to the more easy part.</p>

<h3>4 - Use <code>UpPlug</code> in the project</h3>

<p>We have done the hard part. Now is the fun part where we will use the <code>UpPlug</code> and apply into the hardware zone app. Open the <code>hardwares_controller.ex</code>:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>vim web/controllers/hardwares_controller.ex
</code></pre></div>
<p>and add in the following private function at the end of the file. This function is basically just a wrapper of the <code>UpPlug.process_upload_plug</code> call when there is an attachment received. Note that you will need to update the model struct after done with the file processing by triggering <code>Repo.update(...)</code> - occurs on line 9 of the code below: </p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">defp</span> <span class="n">upload_photo_attachment</span><span class="p">(</span><span class="n">hardware</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">attachment_attribute_name</span><span class="p">)</span> <span class="k">do</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">attachment_attribute_name</span><span class="p">]</span> <span class="o">!=</span> <span class="no">nil</span> <span class="ow">and</span> <span class="err">\</span>
          <span class="nc">String</span><span class="p">.</span><span class="n">length</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">attachment_attribute_name</span><span class="p">].</span><span class="n">filename</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">hardware</span> <span class="p">=</span> <span class="nc">UpPlug</span><span class="p">.</span><span class="n">process_upload_plug</span><span class="p">(%</span><span class="nc">UpPlug</span><span class="p">{</span>
      <span class="ss">model</span><span class="p">:</span> <span class="n">hardware</span><span class="p">,</span>
      <span class="ss">plug</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="n">attachment_attribute_name</span><span class="p">],</span>
      <span class="ss">attribute_name</span><span class="p">:</span> <span class="n">attachment_attribute_name</span><span class="p">,</span>
      <span class="ss">styles</span><span class="p">:</span> <span class="p">%{</span> <span class="ss">thumb</span><span class="p">:</span> <span class="s2">&quot;100x100&gt;&quot;</span><span class="p">,</span> <span class="ss">large</span><span class="p">:</span> <span class="s2">&quot;300x300&gt;&quot;</span> <span class="p">}</span>
    <span class="p">})</span>
    <span class="n">hardware</span> <span class="p">=</span> <span class="nc">Map</span><span class="p">.</span><span class="n">delete</span><span class="p">(</span><span class="n">hardware</span><span class="p">,</span> <span class="ss">:photo</span><span class="p">)</span>
    <span class="nc">Repo</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">hardware</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>As you can see, we are generating 2 styles for this uploaded photo: <code>thumb</code> (<code>100x100&gt;</code>) and <code>large</code> (<code>300x300&gt;</code>). We will use these 2 styles in 2 different places. They are inside <code>create</code> and <code>update</code> function as following:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="p">...</span>
<span class="kd">def</span> <span class="n">create</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="p">%{</span><span class="s2">&quot;hardware&quot;</span> <span class="p">=&gt;</span> <span class="n">params</span><span class="p">})</span> <span class="k">do</span>
  <span class="n">atomized_keys_params</span> <span class="p">=</span> <span class="n">atomize_keys</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
  <span class="n">hardware</span> <span class="p">=</span> <span class="nc">Map</span><span class="p">.</span><span class="n">merge</span><span class="p">(%</span><span class="nc">Hardware</span><span class="p">{},</span> <span class="n">atomized_keys_params</span><span class="p">)</span>
  <span class="k">case</span> <span class="nc">Hardware</span><span class="p">.</span><span class="n">validate</span><span class="p">(</span><span class="n">hardware</span><span class="p">)</span> <span class="k">do</span>
    <span class="p">[]</span> <span class="p">-&gt;</span>
      <span class="n">hardware</span> <span class="p">=</span> <span class="nc">Repo</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">hardware</span><span class="p">)</span>
      <span class="n">upload_photo_attachment</span><span class="p">(</span><span class="n">hardware</span><span class="p">,</span> <span class="n">atomized_keys_params</span><span class="p">,</span> <span class="ss">:photo</span><span class="p">)</span>
      <span class="n">redirect</span> <span class="n">conn</span><span class="p">,</span> <span class="nc">Router</span><span class="p">.</span><span class="n">hardwares_path</span><span class="p">(</span><span class="ss">:show</span><span class="p">,</span> <span class="n">hardware</span><span class="p">.</span><span class="n">id</span><span class="p">)</span>
    <span class="n">errors</span> <span class="p">-&gt;</span>
      <span class="n">render</span> <span class="n">conn</span><span class="p">,</span> <span class="s2">&quot;new&quot;</span><span class="p">,</span> <span class="ss">hardware</span><span class="p">:</span> <span class="n">hardware</span><span class="p">,</span> <span class="ss">errors</span><span class="p">:</span> <span class="n">errors</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="p">...</span>

<span class="kd">def</span> <span class="n">update</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="p">%{</span><span class="s2">&quot;id&quot;</span> <span class="p">=&gt;</span> <span class="n">id</span><span class="p">,</span> <span class="s2">&quot;hardware&quot;</span> <span class="p">=&gt;</span> <span class="n">params</span><span class="p">})</span> <span class="k">do</span>
  <span class="k">case</span> <span class="nc">Repo</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="nc">Hardware</span><span class="p">,</span> <span class="nc">String</span><span class="p">.</span><span class="n">to_integer</span><span class="p">(</span><span class="n">id</span><span class="p">))</span> <span class="k">do</span>
    <span class="n">hardware</span> <span class="ow">when</span> <span class="n">is_map</span><span class="p">(</span><span class="n">hardware</span><span class="p">)</span> <span class="p">-&gt;</span>
      <span class="n">atomized_keys_params</span> <span class="p">=</span> <span class="n">atomize_keys</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
      <span class="n">hardware</span> <span class="p">=</span> <span class="nc">Map</span><span class="p">.</span><span class="n">merge</span><span class="p">(</span><span class="n">hardware</span><span class="p">,</span> <span class="n">atomized_keys_params</span><span class="p">)</span>
      <span class="k">case</span> <span class="nc">Hardware</span><span class="p">.</span><span class="n">validate</span><span class="p">(</span><span class="n">hardware</span><span class="p">)</span> <span class="k">do</span>
        <span class="p">[]</span> <span class="p">-&gt;</span>
          <span class="nc">Repo</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">hardware</span><span class="p">)</span>
          <span class="n">upload_photo_attachment</span><span class="p">(</span><span class="n">hardware</span><span class="p">,</span> <span class="n">atomized_keys_params</span><span class="p">,</span> <span class="ss">:photo</span><span class="p">)</span>
          <span class="n">redirect</span> <span class="n">conn</span><span class="p">,</span> <span class="nc">Router</span><span class="p">.</span><span class="n">hardwares_path</span><span class="p">(</span><span class="ss">:show</span><span class="p">,</span> <span class="n">hardware</span><span class="p">.</span><span class="n">id</span><span class="p">)</span>
        <span class="n">errors</span> <span class="p">-&gt;</span>
          <span class="n">render</span> <span class="n">conn</span><span class="p">,</span> <span class="s2">&quot;edit&quot;</span><span class="p">,</span> <span class="ss">hardware</span><span class="p">:</span> <span class="n">hardware</span><span class="p">,</span> <span class="ss">errors</span><span class="p">:</span> <span class="n">errors</span>
      <span class="k">end</span>
    <span class="bp">_</span> <span class="p">-&gt;</span>
      <span class="n">redirect</span> <span class="n">conn</span><span class="p">,</span> <span class="nc">Router</span><span class="p">.</span><span class="n">hardwares_path</span><span class="p">(</span><span class="ss">:index</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>Now, let&#39;s move on to displaying the photos. First edit the template <code>web/templates/hardwares/index.html.eex</code> to show the thumbnail of the hardware photo in the list of hardwares:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>vim web/templates/hardwares/index.html.eex
</code></pre></div>
<p>and add in the folling line under <code>&lt;div class=&quot;description&quot;&gt;&lt;/div&gt;</code> tag</p>
<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&#39;photo&#39;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;img</span> <span class="na">src=</span><span class="s">&#39;&lt;%= UpPlug.attachment_url_for(</span>
<span class="s">                           hardware, :photo, :thumb, &quot;/images/no_photo_thumb.png&quot;)  %&gt;&#39;</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</code></pre></div>
<p>Next, we will also need to edit the show template at <code>web/templates/hardwares/show.html.eex</code> to show a bigger version of the photo:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>vim web/templates/hardwares/show.html.eex
</code></pre></div>
<p>Replace the part to display the hardware with the following</p>
<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;h1&gt;</span><span class="err">&lt;</span>%= @hardware.name %&gt;<span class="nt">&lt;/h1&gt;</span>
<span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;row&quot;</span><span class="nt">&gt;</span>

  <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;col-sm-6&quot;</span><span class="nt">&gt;</span> 
    <span class="nt">&lt;span</span> <span class="na">class=</span><span class="s">&#39;manufacturer&#39;</span><span class="nt">&gt;</span><span class="err">&lt;</span>%= @hardware.manufacturer %&gt;<span class="nt">&lt;/span&gt;</span>

    <span class="nt">&lt;br/&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&#39;description&#39;</span><span class="nt">&gt;</span><span class="err">&lt;</span>%= @hardware.description %&gt;<span class="nt">&lt;/div&gt;</span>

    <span class="err">&lt;</span>%= if @hardware.sale_contact_number do %&gt;
      Want to buy, contact me at: <span class="err">&lt;</span>%= @hardware.sale_contact_number %&gt;
    <span class="err">&lt;</span>% end %&gt;
    <span class="nt">&lt;br/&gt;&lt;br/&gt;</span>
  <span class="nt">&lt;/div&gt;</span>

  <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;col-sm-6&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;img</span> <span class="na">src=</span><span class="s">&#39;&lt;%= UpPlug.attachment_url_for(</span>
<span class="s">                            @hardware, :photo, :large, &quot;/images/no_photo_large.png&quot;) %&gt;&#39;</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;br/&gt;&lt;br/&gt;</span>
</code></pre></div>
<p>We will need to modify the style so that it will fit the uploaded photo. Let&#39;s edit <code>priv/static/css/app.css</code></p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>vim priv/static/css/app.css
</code></pre></div>
<p>and change the height in <code>div.hardware-box</code> height to <code>235px</code></p>
<div class="highlight"><pre><code class="language-css" data-lang="css"><span class="nt">div</span><span class="nc">.hardware-box</span> <span class="p">{</span>
  <span class="k">border</span><span class="o">:</span> <span class="m">1px</span> <span class="k">solid</span> <span class="m">#ccc</span><span class="p">;</span>
  <span class="k">padding</span><span class="o">:</span> <span class="m">10px</span><span class="p">;</span>
  <span class="k">height</span><span class="o">:</span> <span class="m">235px</span><span class="p">;</span>
  <span class="k">background</span><span class="o">:</span> <span class="m">#efefef</span><span class="p">;</span>
  <span class="k">margin-top</span><span class="o">:</span> <span class="m">30px</span><span class="p">;</span>
  <span class="k">cursor</span><span class="o">:</span> <span class="k">pointer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>And add <code>margin-bottom: 10px;</code> to <code>div.hardware-box div.description</code> style</p>
<div class="highlight"><pre><code class="language-css" data-lang="css"><span class="nt">div</span><span class="nc">.hardware-box</span> <span class="nt">div</span><span class="nc">.description</span> <span class="p">{</span>
  <span class="k">margin-top</span><span class="o">:</span> <span class="m">10px</span><span class="p">;</span>
  <span class="k">height</span><span class="o">:</span> <span class="m">60px</span><span class="p">;</span>
  <span class="k">overflow</span><span class="o">:</span> <span class="k">hidden</span><span class="p">;</span>
  <span class="k">margin-bottom</span><span class="o">:</span> <span class="m">10px</span><span class="p">;</span>
<span class="p">}</span> 
</code></pre></div>
<p>Finally, copy the following 2 files into your <code>priv/static/images</code> folder. These 2 files are used to cater for the case that a hardware does not have a photo yet:</p>

<ul>
<li><a href="https://raw.githubusercontent.com/learnelixir/hardware-zone/master/priv/static/images/no_photo_large.png">https://raw.githubusercontent.com/learnelixir/hardware-zone/master/priv/static/images/no_photo_large.png</a></li>
<li><a href="https://raw.githubusercontent.com/learnelixir/hardware-zone/master/priv/static/images/no_photo_thumb.png">https://raw.githubusercontent.com/learnelixir/hardware-zone/master/priv/static/images/no_photo_thumb.png</a></li>
</ul>

<p>After this, you can start your phoenix server and enjoy the web application with the ability to upload and process photos.</p>

<h3>Conclusion</h3>

<p>I hope that I have covered something missing at the point of this article and I do hope that you enjoy the article. If you have any comments or questions, please put those in the comments box below. The <code>UpPlug</code> library can be enhanced in many ways, below are some of them:</p>

<ul>
<li>Uploaded File validation in term of file size and content type.</li>
<li>Supporting Amazon S3 file upload.</li>
<li>Callback after <code>Repo.update</code> or <code>Repo.insert</code> instead of calling the process uploaded file function inside the controller</li>
<li>Callback support for uploaded file after it has been processed.</li>
</ul>

<p>That&#39;s all for now. Thank you for your time. :-)</p>
]]></content>
  </entry>
  
</feed>
