<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Mix | Learn Elixir Language]]></title>
  <link href="http://learnelixir.com/blog/categories/mix/atom.xml" rel="self"/>
  <link href="http://learnelixir.com/"/>
  <updated>2014-11-07T07:12:48+08:00</updated>
  <id>http://learnelixir.com/</id>
  <author>
    <name><![CDATA[Learn Elixir]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[A Custom Mix Task for Phoenix App]]></title>
    <link href="http://learnelixir.com/blog/2014/11/04/custom-mix-task-for-phoenix-app/"/>
    <updated>2014-11-04T23:35:23+08:00</updated>
    <id>http://learnelixir.com/blog/2014/11/04/custom-mix-task-for-phoenix-app</id>
    <content type="html"><![CDATA[<p>Mix task is a powerful way to automate certain things from command line. It&#39;s especially helpful when dealing with code generator. In this article, we are going to write a custom mix task for Phoenix application to automate generation of Model, its Repo and Migration task. I usually have to generate these one by one manually at the moment.</p>

<!-- more -->

<h3>Expected Result</h3>

<p>First, make sure that our app has the following dependencies in <code>mix.exs</code> file:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">def</span> <span class="n">application</span> <span class="k">do</span>
  <span class="p">[</span>
    <span class="ss">mod</span><span class="p">:</span> <span class="p">{</span> <span class="nc">HardwareZone</span><span class="p">,</span> <span class="p">[]</span> <span class="p">},</span>
    <span class="ss">applications</span><span class="p">:</span> <span class="p">[</span><span class="ss">:phoenix</span><span class="p">,</span> <span class="ss">:cowboy</span><span class="p">,</span> <span class="ss">:logger</span><span class="p">,</span> <span class="ss">:postgrex</span><span class="p">,</span> <span class="ss">:ecto</span><span class="p">]</span>
  <span class="p">]</span>
<span class="k">end</span>

<span class="kd">defp</span> <span class="n">deps</span> <span class="k">do</span>
  <span class="p">[</span>   
    <span class="p">{</span><span class="ss">:phoenix</span><span class="p">,</span> <span class="s2">&quot;0.5.0&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="ss">:cowboy</span><span class="p">,</span> <span class="s2">&quot;~&gt; 1.0.0&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="ss">:postgrex</span><span class="p">,</span> <span class="s2">&quot;~&gt; 0.5&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="ss">:ecto</span><span class="p">,</span> <span class="s2">&quot;~&gt; 0.2.0&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="ss">:inflex</span><span class="p">,</span> <span class="s2">&quot;~&gt; 0.2.5&quot;</span><span class="p">}</span>
  <span class="p">]</span>   
<span class="k">end</span> 
</code></pre></div>
<p>Then run:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ mix do deps.get, compile
</code></pre></div>
<p>Now, to start, let&#39;s write out our final goal. From the terminal, if let say we enter the following command and hit enter:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">mix potion.g model hardware name:string description:text released_year:integer purchased_on:date 
</code></pre></div>
<p>It should generate the following:</p>

<ul>
<li>A Repo file if it does not exist yet. </li>
<li>Hardware struct model with the specified attributes name with string column type, description with text column type, released year with integer column type, and purchased_on with column date.</li>
<li>Database Migration file for this Hardware model.</li>
</ul>

<p>Note that this is for us to learn how to write a custom mix command for Phoenix app. We will not be able to cover the entire syntax for generating a model like Rails.</p>

<h3>Simple Mix Task</h3>

<p>Let&#39;s move to create a simple mix task, which is going to display the list of arguments from the command line. Inside your Phoenix app, let&#39;s create the following folder:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>mkdir -p lib/mix/tasks
</code></pre></div>
<p>Then create a mix task file:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>vim lib/mix/tasks/g.ex
</code></pre></div>
<p>with the following initial code:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">defmodule</span> <span class="nc">Mix.Tasks.Potion</span> <span class="k">do</span>
  <span class="kd">defmodule</span> <span class="nc">G</span> <span class="k">do</span>
    <span class="kn">use</span> <span class="nc">Mix.Task</span>
    <span class="kn">import</span> <span class="nc">Mix.Generator</span>
    <span class="kn">import</span> <span class="nc">Mix.Utils</span><span class="p">,</span> <span class="ss">only</span><span class="p">:</span> <span class="p">[</span><span class="ss">camelize</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="ss">underscore</span><span class="p">:</span> <span class="mi">1</span><span class="p">]</span> 

    <span class="na">@shortdoc</span> <span class="s2">&quot;For model code generation.&quot;</span>

    <span class="na">@moduledoc</span> <span class="sh">&quot;&quot;&quot; </span>
<span class="sh">      A task for generating model struct, its database migration and Repo if one does not yet exist.</span>
<span class="sh">    &quot;&quot;&quot;</span>

    <span class="kd">def</span> <span class="n">run</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="k">do</span>
      <span class="nc">IO</span><span class="p">.</span><span class="n">puts</span> <span class="p">(</span><span class="n">inspect</span> <span class="n">args</span><span class="p">)</span>
    <span class="k">end</span> 
  <span class="k">end</span> 
<span class="k">end</span>
</code></pre></div>
<p>Note that, the function <code>def run(args)</code> is the entry point. When you run this task, the run command will be executed. We have also imported a few things here: </p>

<ul>
<li><code>Mix.Generator</code> provides us helper for <code>create_file</code>, <code>embed_template</code>, <code>create_directory</code></li>
<li><code>Mix.Utils</code> provides us helper for <code>camelize</code> and <code>underscore</code> </li>
</ul>

<p>To run this mix task, we can either run this command:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>mix Potion.G
</code></pre></div>
<p>or this command:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>mix potion.g
</code></pre></div>
<p>I would prefer the later way caused I do not need to press an extra shift key :p. Anyway, after you run the task, you should expect to see the following output:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="o">[]</span>
</code></pre></div>
<p>It is displaying an empty array because we are printing out the inspection of arguments, which are none at the moment. If you try to run the command like below:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>mix potion.g model hardware name:string description:text released_year:integer purchased_on:date 
</code></pre></div>
<p>You should see the following:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="o">[</span><span class="s2">&quot;model&quot;</span>, <span class="s2">&quot;hardware&quot;</span>, <span class="s2">&quot;name:string&quot;</span>, <span class="s2">&quot;description:text&quot;</span>, <span class="se">\</span>
<span class="s2">&quot;released_year:integer&quot;</span>, <span class="s2">&quot;purchased_on:date&quot;</span><span class="o">]</span>
</code></pre></div>
<p>That&#39;s how we can get in arguments from the command line.</p>

<h3>Expand mix task for model generation</h3>

<p>Since we know that the mix task that we are going to write is to cater only for model, we can write the <code>run</code> command in such a way that it will immediately recognize the arguments from the command line without doing any checking. We can do that by spliting the <code>run</code> command into 2 parts as per following:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">def run<span class="o">([</span><span class="s2">&quot;model&quot;</span> <span class="p">|</span> <span class="o">[</span>model_name <span class="p">|</span> attributes<span class="o">]])</span> <span class="k">do</span>
  IO.puts <span class="s2">&quot;Generate model #{model_name} with the following attributes #{inspect attributes}&quot;</span>
end 

def run<span class="o">(</span>_<span class="o">)</span> <span class="k">do</span>
  IO.puts <span class="s2">&quot;Incorrect syntax. Please try mix potion.g model &lt;model_name&gt; [attribute1] [attribute2]...&quot;</span>
end 
</code></pre></div>
<p>We are now ready to write the generator for our first task - Repo</p>

<h3>Generating Repo file</h3>

<p>It will be more convenient if we have a template file and just need to plug in the parts that are dynamic. Hence, let&#39;s define a template file for Repo. It can be achieved by using <code>embed_template</code> command as following:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="n">embed_template</span> <span class="ss">:repo</span><span class="p">,</span> <span class="sh">&quot;&quot;&quot; </span>
<span class="sh">defmodule &lt;%= inspect @repo_module %&gt; do</span>
<span class="sh">  use Ecta.Repo, adapter: Ecto.Adapters.Postgres</span>
<span class="sh">  h</span>

<span class="sh">  def conf do</span>
<span class="sh">    parse_url &quot;ecto://&lt;username&gt;:&lt;password&gt;@localhost/&lt;%= @database_name %&gt;&quot;</span>
<span class="sh">  end </span>

<span class="sh">  def priv do</span>
<span class="sh">    app_dir(:&lt;%= @app_name %&gt;, &quot;priv/repo&quot;)</span>
<span class="sh">  end </span>
<span class="sh">end</span>
<span class="sh">&quot;&quot;&quot;</span>
</code></pre></div>
<p>As you have noticed, we are using the variable with <code>@</code> sign in front. These are variables that we will need to pass in when we call function <code>repo_template</code>. Note that, as are using the template with name <code>repo</code> here, we can call function <code>repo_template</code>. The Generator helper has automagically created that function for us. What we will need to do next is find <code>repo_module</code> and the <code>app_name</code> to plug in the template. Let&#39;s go back to the <code>run</code> function, and add in the below code:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">def</span> <span class="n">run</span><span class="p">([</span><span class="s2">&quot;model&quot;</span> <span class="p">|</span> <span class="p">[</span><span class="n">model_name</span> <span class="p">|</span> <span class="n">attributes</span><span class="p">]])</span> <span class="k">do</span>
  <span class="n">app_name</span> <span class="p">=</span> <span class="nc">Mix.Project</span><span class="p">.</span><span class="n">config</span><span class="p">[</span><span class="ss">:app</span><span class="p">]</span>
  <span class="n">project_module_name</span> <span class="p">=</span> <span class="n">camelize</span><span class="p">(</span><span class="n">to_string</span><span class="p">(</span><span class="n">app_name</span><span class="p">))</span>
  <span class="n">repo_module</span> <span class="p">=</span> <span class="nc">Module</span><span class="p">.</span><span class="n">concat</span><span class="p">([</span><span class="n">project_module_name</span><span class="p">,</span> <span class="s2">&quot;Repo&quot;</span><span class="p">])</span>
<span class="k">end</span>
</code></pre></div>
<p>As you can see, on the second line of the above code, we can easily extract out the app name by using <code>Mix.Project.config[:app]</code>. We then convert this app name to the name of the module corresponding to the app name by using the <code>camelize</code> function. Finally, we use <code>Module.concat</code> to form the <code>Repo</code> module name when combining the app module with <code>Repo</code>. After having these 2 variables, we then can write a function taking these 2 parameters to generate the Repo file. Let&#39;s define function named <code>generate_repo_file</code>:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">defp</span> <span class="n">generate_repo_file</span><span class="p">(</span><span class="n">app_name</span><span class="p">,</span> <span class="n">repo_module</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">repo_path</span> <span class="p">=</span> <span class="nc">Path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="nc">System</span><span class="p">.</span><span class="n">cwd</span><span class="p">(),</span> <span class="s2">&quot;web/models/repo.ex&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nc">File</span><span class="p">.</span><span class="n">exists?</span><span class="p">(</span><span class="n">repo_path</span><span class="p">)</span> <span class="o">==</span> <span class="no">false</span> <span class="k">do</span> 
    <span class="n">create_file</span> <span class="n">repo_path</span><span class="p">,</span> <span class="n">repo_template</span><span class="p">(</span>
      <span class="ss">repo_module</span><span class="p">:</span> <span class="n">repo_module</span><span class="p">,</span>
      <span class="ss">app_name</span><span class="p">:</span> <span class="n">app_name</span>
    <span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>We have constructed the path to the repo file by joining <code>Sysytem.cwd()</code>, used to generate the absolute path of the current folder with the relative path to the expected repo file (<code>web/models/repo.ex</code>). We then check whether the file exists. If it does not exist, we would create the file using <code>create_file</code> command. As mentioned above, we have used <code>repo_template</code> function to create the actual file from the template by passing 2 neccesary parameters <code>repo_module</code> and <code>app_name</code>. Finally, we will need to call this inside <code>run</code> function:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="n">generate_repo_file</span><span class="p">(</span><span class="n">app_name</span><span class="p">,</span> <span class="n">repo_module</span><span class="p">)</span>
</code></pre></div>
<p>That&#39;s all for generating a Repo file. Let&#39;s move on to generating the model file.</p>

<h3>Generating Model file</h3>

<p>Similar to what we have done when we generate the Repo file, we will need to create a template file as following:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="n">embed_template</span> <span class="ss">:model</span><span class="p">,</span> <span class="sh">&quot;&quot;&quot;</span>
<span class="sh">defmodule &lt;%= @model_name %&gt; do</span>
<span class="sh">  use Ecto.Model</span>

<span class="sh">  schema &quot;&lt;%= @table_name %&gt;&quot; do</span>
<span class="sh">    &lt;%= @attributes_table %&gt;</span>
<span class="sh">  end </span>
<span class="sh">end  </span>
<span class="sh">&quot;&quot;&quot;</span>
</code></pre></div>
<p>As you can see, there are 3 missing pieces that we will need to find out: <code>model_name</code>, <code>table_name</code> and <code>attributes_table</code>. For <code>model_name</code>, we can easily extracy out the model name  by using <code>camelize</code> function on the model name from command line&#39;s argument. Whereas for <code>table_name</code>, we will need to pluralize the underscored string of the model name. For instance, a <code>UserProfile</code> model will need a table named <code>user_profiles</code>. Lastly, for <code>attributes_table</code>, we will have to translate the list of attributes keyed in by user into the syntax recognised by <code>Ecto</code>. Let&#39;s go ahead and write the function to generate the <code>atributes_table</code>:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">def</span> <span class="n">attributes_table_from_attributes_array</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span> <span class="k">do</span>
  <span class="nc">Enum</span><span class="p">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">attributes</span><span class="p">,</span> <span class="p">%{},</span> <span class="k">fn</span><span class="p">(</span><span class="n">attribute</span><span class="p">,</span> <span class="n">dict</span><span class="p">)</span> <span class="p">-&gt;</span>
    <span class="k">if</span> <span class="nc">String</span><span class="p">.</span><span class="n">contains?</span><span class="p">(</span><span class="n">attribute</span><span class="p">,</span> <span class="s2">&quot;:&quot;</span><span class="p">)</span> <span class="k">do</span>
      <span class="p">[</span><span class="n">attribute_name</span><span class="p">,</span> <span class="n">attribute_type</span><span class="p">]</span> <span class="p">=</span> <span class="nc">String</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="n">attribute</span><span class="p">,</span> <span class="s2">&quot;:&quot;</span><span class="p">)</span>
    <span class="k">else</span> <span class="c1"># if not specify attribute type, it will be deemed as string</span>
      <span class="p">[</span><span class="n">attribute_name</span><span class="p">,</span> <span class="n">attribute_type</span><span class="p">]</span> <span class="p">=</span> <span class="p">[</span><span class="n">attribute</span><span class="p">,</span> <span class="s2">&quot;string&quot;</span><span class="p">]</span>
    <span class="k">end</span>

    <span class="n">model_attributes_table</span> <span class="p">=</span> <span class="nc">Map</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">dict</span><span class="p">,</span> <span class="ss">:for_model_file</span><span class="p">,</span> <span class="p">[])</span>
    <span class="n">model_attributes_table</span> <span class="p">=</span> <span class="n">model_attributes_table</span> <span class="err">\</span>
          <span class="o">++</span> <span class="p">[</span><span class="s2">&quot;field :</span><span class="si">#{</span><span class="n">attribute_name</span><span class="si">}</span><span class="s2">, :</span><span class="si">#{</span><span class="n">ecto_attribute_type_map</span><span class="p">(</span><span class="n">attribute_type</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
    <span class="n">dict</span> <span class="p">=</span> <span class="nc">Map</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">dict</span><span class="p">,</span> <span class="ss">:for_model_file</span><span class="p">,</span> <span class="n">model_attributes_table</span><span class="p">)</span>
  <span class="k">end</span><span class="p">)</span>
<span class="k">end</span>

<span class="kd">def</span> <span class="n">ecto_attribute_type_map</span><span class="p">(</span><span class="n">attribute_type</span><span class="p">)</span> <span class="k">do</span>
  <span class="k">case</span> <span class="n">attribute_type</span> <span class="k">do</span>
    <span class="s2">&quot;text&quot;</span> <span class="p">-&gt;</span> <span class="s2">&quot;string&quot;</span>
    <span class="n">other</span> <span class="p">-&gt;</span> <span class="n">other</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>As you can see in the above code, I have used <code>Enum.reduce</code> to transform the array of attributes into a hash, which has <code>for_model_file</code> key mapped to a list of lines, each of which is as following:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="n">field</span> <span class="o">&lt;</span><span class="n">attribute_name</span><span class="o">&gt;</span><span class="p">,</span> <span class="ss">:&lt;</span><span class="n">attribute_type_corresponding_to_ecto</span><span class="o">&gt;</span>
</code></pre></div>
<p>For each of the attribute part passed from the command line, we need check if it contains a colon <code>:</code>. If it does, we will then split the colon and assign the first part as attribute name and the second part as attribute type. If it does not, the attribute type is default as string. This attribute type will then be mapped with the correct type in Ecto. For instance, if you look at <code>ecto_attribute_type_map</code> function, we are mapping the <code>text</code> type to be <code>string</code> as there is no <code>text</code> type in Ecto. </p>

<p>If you want to have more convience, for instance, you can map <code>i</code> with <code>integer</code>. Hence, when youu write a generate command, it can be like the following:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ mix potion.g user account_id:i
</code></pre></div>
<p>the attribute <code>account_id:i</code> will then be translated as:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="n">field</span> <span class="n">account_id</span><span class="p">,</span> <span class="ss">:integer</span>
</code></pre></div>
<p>Having the attributes table, we now can define the function to generate the model file as following:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">defp</span> <span class="n">generate_model_file</span><span class="p">(</span><span class="n">model_name</span><span class="p">,</span> <span class="n">project_module_name</span><span class="p">,</span> <span class="n">attributes_map</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">model_destination</span> <span class="p">=</span> <span class="nc">Path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="nc">System</span><span class="p">.</span><span class="n">cwd</span><span class="p">(),</span> <span class="s2">&quot;/web/models/</span><span class="si">#{</span><span class="n">underscore</span><span class="p">(</span><span class="n">model_name</span><span class="p">)</span><span class="si">}</span><span class="s2">.ex&quot;</span><span class="p">)</span>
  <span class="n">create_file</span> <span class="n">model_destination</span><span class="p">,</span> <span class="n">model_template</span><span class="p">(</span>
      <span class="ss">model_name</span><span class="p">:</span> <span class="nc">Module</span><span class="p">.</span><span class="n">concat</span><span class="p">(</span><span class="n">project_module_name</span><span class="p">,</span> <span class="n">camelize</span><span class="p">(</span><span class="n">model_name</span><span class="p">)),</span>
      <span class="ss">table_name</span><span class="p">:</span> <span class="nc">Inflex</span><span class="p">.</span><span class="n">pluralize</span><span class="p">(</span><span class="n">underscore</span><span class="p">(</span><span class="n">model_name</span><span class="p">)),</span>
      <span class="ss">attributes_table</span><span class="p">:</span> <span class="nc">Enum</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">attributes_map</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n\t\t</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="p">)</span>
<span class="k">end</span>
</code></pre></div>
<p>Similar to what we have done with <code>Repo</code> file, we have generated the path of the model file using <code>File.join</code> command. We then use <code>create_file</code> with <code>model_template</code> function and supplying the 3 arguments:</p>

<ul>
<li><code>model_name</code>: e.g. <code>HardwareZone.UserProfile</code></li>
<li><code>table_name</code>: e.g. <code>user_profiles</code> - by using <code>Inflex.pluralize(underscore(model_name))</code></li>
<li><code>atributes_table</code>: e.g. we are joining each entries of the list that we generated in the earlier step with <code>\n\t\t</code> . You can modify this as what you want.</li>
</ul>

<p>Lastly, for this part, let&#39;s combine all together in the <code>run</code> command:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="p">...</span>
<span class="n">attributes_table_map</span> <span class="p">=</span> <span class="n">attributes_table_from_attributes_array</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span>
<span class="n">generate_model_file</span><span class="p">(</span><span class="n">model_name</span><span class="p">,</span> <span class="n">project_module_name</span><span class="p">,</span> <span class="err">\</span>  
    <span class="nc">Map</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">attributes_table_map</span><span class="p">,</span> <span class="ss">:for_model_file</span><span class="p">,</span> <span class="p">[]))</span>
</code></pre></div>
<h3>Generate Migration file</h3>

<p>The last part of this is generating the corresponding Migration file. As you might know, Ecto comes with a predefined migration file generation. However, I am not so happy with it as what it does is just generating a blank migration file. What I really want is a full migration file and ready to be migrated :-). So let&#39;s start by defining the template. This is the template from Ecto migration task with some modifications. We have added in <code>@table_up</code> and <code>@table_down</code> attributes inside this template:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">defmodule</span> <span class="o">&lt;</span><span class="p">%=</span> <span class="n">inspect</span> <span class="na">@mod</span> <span class="p">%</span><span class="o">&gt;</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="nc">Ecto.Migration</span>

  <span class="kd">def</span> <span class="n">up</span> <span class="k">do</span>
    <span class="s2">&quot;&lt;%= @table_up %&gt;&quot;</span>
  <span class="k">end</span>

  <span class="kd">def</span> <span class="n">down</span> <span class="k">do</span>
    <span class="s2">&quot;&lt;%= @table_down %&gt;&quot;</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="sh">&quot;&quot;&quot;</span>
</code></pre></div>
<p>For <code>table_down</code> code, it is pretty straight forward. In particular, it will be always <code>DROP TABLE &lt;table_name&gt;</code>. For <code>table_up</code>, we will need to generate a list of attribute name mapped with the corresponding in Postgres. What  we will need to do is to write the function <code>postgres_attribute_type_map</code> as following:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">def</span> <span class="n">postgres_attribute_type_map</span><span class="p">(</span><span class="n">attribute_type</span><span class="p">)</span> <span class="k">do</span>
  <span class="k">case</span> <span class="n">attribute_type</span> <span class="k">do</span>
    <span class="s2">&quot;float&quot;</span> <span class="p">-&gt;</span> <span class="s2">&quot;real&quot;</span>
    <span class="s2">&quot;string&quot;</span> <span class="p">-&gt;</span> <span class="s2">&quot;varchar(255)&quot;</span>
    <span class="s2">&quot;decimal&quot;</span> <span class="p">-&gt;</span> <span class="s2">&quot;decimal(10, 4)&quot;</span>
    <span class="s2">&quot;datetime&quot;</span> <span class="p">-&gt;</span> <span class="s2">&quot;timestamp&quot;</span>
    <span class="n">other</span> <span class="p">-&gt;</span> <span class="n">other</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>You will notice that it is quite similar to the function <code>ecto_attribute_type_map</code> that we wrote earlier. Here, I have just outlined a few that I will need but you are free to add in more as per your need. Next, inside the function that  we already have - <code>attributes_table_from_attributes_array</code>, let&#39;s add the below code to the function block of <code>Enum.reduce</code>:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="n">migration_attributes_table</span> <span class="p">=</span> <span class="nc">Map</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">dict</span><span class="p">,</span> <span class="ss">:for_migration_file</span><span class="p">,</span> <span class="p">[])</span>
<span class="n">migration_attributes_table</span> <span class="p">=</span> <span class="n">migration_attributes_table</span> <span class="err">\</span>
    <span class="o">++</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">#{</span><span class="n">attribute_name</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="n">postgres_attribute_type_map</span><span class="p">(</span><span class="n">attribute_type</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
<span class="n">dict</span> <span class="p">=</span> <span class="nc">Map</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">dict</span><span class="p">,</span> <span class="ss">:for_migration_file</span><span class="p">,</span> <span class="n">migration_attributes_table</span><span class="p">)</span>
</code></pre></div>
<p>Our complete <code>attributes_table_from_attributes_array</code> function will look like this:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">def</span> <span class="n">attributes_table_from_attributes_array</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span> <span class="k">do</span>
  <span class="nc">Enum</span><span class="p">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">attributes</span><span class="p">,</span> <span class="p">%{},</span> <span class="k">fn</span><span class="p">(</span><span class="n">attribute</span><span class="p">,</span> <span class="n">dict</span><span class="p">)</span> <span class="p">-&gt;</span>
    <span class="k">if</span> <span class="nc">String</span><span class="p">.</span><span class="n">contains?</span><span class="p">(</span><span class="n">attribute</span><span class="p">,</span> <span class="s2">&quot;:&quot;</span><span class="p">)</span> <span class="k">do</span>
      <span class="p">[</span><span class="n">attribute_name</span><span class="p">,</span> <span class="n">attribute_type</span><span class="p">]</span> <span class="p">=</span> <span class="nc">String</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="n">attribute</span><span class="p">,</span> <span class="s2">&quot;:&quot;</span><span class="p">)</span>
    <span class="k">else</span> <span class="c1"># if not specify attribute type, it will be deemed as string</span>
      <span class="p">[</span><span class="n">attribute_name</span><span class="p">,</span> <span class="n">attribute_type</span><span class="p">]</span> <span class="p">=</span> <span class="p">[</span><span class="n">attribute</span><span class="p">,</span> <span class="s2">&quot;string&quot;</span><span class="p">]</span>
    <span class="k">end</span>

    <span class="n">model_attributes_table</span> <span class="p">=</span> <span class="nc">Map</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">dict</span><span class="p">,</span> <span class="ss">:for_model_file</span><span class="p">,</span> <span class="p">[])</span>
    <span class="n">model_attributes_table</span> <span class="p">=</span> <span class="n">model_attributes_table</span> <span class="err">\</span>
        <span class="o">++</span> <span class="p">[</span><span class="s2">&quot;field :</span><span class="si">#{</span><span class="n">attribute_name</span><span class="si">}</span><span class="s2">, :</span><span class="si">#{</span><span class="n">ecto_attribute_type_map</span><span class="p">(</span><span class="n">attribute_type</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
    <span class="n">dict</span> <span class="p">=</span> <span class="nc">Map</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">dict</span><span class="p">,</span> <span class="ss">:for_model_file</span><span class="p">,</span> <span class="n">model_attributes_table</span><span class="p">)</span>

    <span class="n">migration_attributes_table</span> <span class="p">=</span> <span class="nc">Map</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">dict</span><span class="p">,</span> <span class="ss">:for_migration_file</span><span class="p">,</span> <span class="p">[])</span>
    <span class="n">migration_attributes_table</span> <span class="p">=</span> <span class="n">migration_attributes_table</span> <span class="err">\</span>
        <span class="o">++</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">#{</span><span class="n">attribute_name</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="n">postgres_attribute_type_map</span><span class="p">(</span><span class="n">attribute_type</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
    <span class="n">dict</span> <span class="p">=</span> <span class="nc">Map</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">dict</span><span class="p">,</span> <span class="ss">:for_migration_file</span><span class="p">,</span> <span class="n">migration_attributes_table</span><span class="p">)</span>
  <span class="k">end</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div>
<p>Now we can define <code>generate_migration_file</code> function as following:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="kd">defp</span> <span class="n">generate_migration_file</span><span class="p">(</span><span class="n">model_name</span><span class="p">,</span> <span class="n">repo_module</span><span class="p">,</span> <span class="n">table_fields</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">path</span> <span class="p">=</span> <span class="nc">Path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="nc">System</span><span class="p">.</span><span class="n">cwd</span><span class="p">(),</span> <span class="s2">&quot;/priv/repo/migrations&quot;</span><span class="p">)</span>
  <span class="n">migration_file</span> <span class="p">=</span> <span class="nc">Path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">timestamp</span><span class="si">}</span><span class="s2">_create_</span><span class="si">#{</span><span class="n">underscore</span><span class="p">(</span><span class="n">model_name</span><span class="p">)</span><span class="si">}</span><span class="s2">.exs&quot;</span><span class="p">)</span>
  <span class="n">table_name</span> <span class="p">=</span> <span class="nc">Inflex</span><span class="p">.</span><span class="n">pluralize</span><span class="p">(</span><span class="n">underscore</span><span class="p">(</span><span class="n">model_name</span><span class="p">))</span>

  <span class="n">create_file</span> <span class="n">migration_file</span><span class="p">,</span> <span class="n">migration_template</span><span class="p">(</span>
    <span class="ss">mod</span><span class="p">:</span> <span class="nc">Module</span><span class="p">.</span><span class="n">concat</span><span class="p">([</span><span class="n">repo_module</span><span class="p">,</span> <span class="nc">Migrations</span><span class="p">,</span> <span class="n">camelize</span><span class="p">(</span><span class="n">model_name</span><span class="p">)]),</span>
    <span class="ss">table_up</span><span class="p">:</span> <span class="s2">&quot;CREATE TABLE </span><span class="si">#{</span><span class="n">table_name</span><span class="si">}</span><span class="s2">( </span><span class="err">\</span><span class="s2"></span>
<span class="s2">                  </span><span class="se">\n\t\t\t\t</span><span class="si">#{</span><span class="nc">Enum</span><span class="p">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;id serial primary key&quot;</span><span class="p">]</span> <span class="o">++</span> <span class="n">table_fields</span><span class="p">,</span> <span class="err">\</span>
                                         <span class="s2">&quot;,</span><span class="se">\n\t\t\t\t</span><span class="s2">&quot;</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">,</span>
    <span class="ss">table_down</span><span class="p">:</span> <span class="s2">&quot;DROP TABLE </span><span class="si">#{</span><span class="n">table_name</span><span class="si">}</span><span class="s2">&quot;</span>
  <span class="p">)</span>
<span class="k">end</span>

<span class="kd">defp</span> <span class="n">timestamp</span> <span class="k">do</span>
  <span class="p">{</span> <span class="p">{</span><span class="n">y</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">d</span><span class="p">},</span> <span class="p">{</span><span class="n">hh</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">ss</span><span class="p">}</span> <span class="p">}</span> <span class="p">=</span> <span class="ss">:calendar</span><span class="p">.</span><span class="n">universal_time</span><span class="p">()</span>
  <span class="s2">&quot;</span><span class="si">#{</span><span class="n">y</span><span class="si">}#{</span><span class="n">pad</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="si">}#{</span><span class="n">pad</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="si">}#{</span><span class="n">pad</span><span class="p">(</span><span class="n">hh</span><span class="p">)</span><span class="si">}#{</span><span class="n">pad</span><span class="p">(</span><span class="n">mm</span><span class="p">)</span><span class="si">}#{</span><span class="n">pad</span><span class="p">(</span><span class="n">ss</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="k">end</span>

<span class="kd">defp</span> <span class="n">pad</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="ow">when</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">,</span> <span class="ss">do</span><span class="p">:</span> <span class="p">&lt;&lt;</span> <span class="sc">?0</span><span class="p">,</span> <span class="sc">?0</span> <span class="o">+</span> <span class="n">i</span> <span class="p">&gt;&gt;</span>
<span class="kd">defp</span> <span class="n">pad</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="ss">do</span><span class="p">:</span> <span class="n">to_string</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</code></pre></div>
<p>Note that <code>timestamp</code>, <code>pad</code> function are the functions I took out from <code>Ecto</code> migration generation file. These are helpers to help generate the file name for the migration file. </p>

<p>As you might notice, we have also done the same thing as when we generate the Model file. We first find the path to the migration file and then create the file using the <code>migration_template</code> function. Again, we have also joined the lines of attribute mapped with its corresponding attribute for Postgres database to form the <code>CREATE TABLE</code> SQL. Finally, we will call this <code>generate_migration_file</code> inside <code>run</code> function:</p>
<div class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="n">generate_migration_file</span><span class="p">(</span><span class="n">model_name</span><span class="p">,</span> <span class="n">project_module_name</span><span class="p">,</span> <span class="err">\</span>
  <span class="nc">Map</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">attributes_table_map</span><span class="p">,</span> <span class="ss">:for_migration_file</span><span class="p">,</span> <span class="p">[]))</span>
</code></pre></div>
<p>That&#39;s all for now. You can get the complete source code for this task in the following URL:</p>

<p><a href="https://raw.githubusercontent.com/learnelixir/hardware-zone/phoenix-0.5.0/lib/mix/tasks/g.ex">https://raw.githubusercontent.com/learnelixir/hardware-zone/phoenix-0.5.0/lib/mix/tasks/g.ex</a></p>

<h3>Conclusion</h3>

<p>With this custom mix task, I can now enjoy generating model file for Phoenix application. This can be easily extended to generate controller file and more migrations, but let&#39;s leave it as it is for now. If you have any suggestions, or better ways of doing this, feel free to let me know. </p>

<p>Happy generating code :-)</p>
]]></content>
  </entry>
  
</feed>
